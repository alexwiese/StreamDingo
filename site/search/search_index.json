{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"StreamDingo Documentation","text":"<p>Welcome to the official documentation for StreamDingo, a high-performance .NET library for event sourcing with hash-based integrity verification and snapshot-based replay.</p>"},{"location":"#overview","title":"Overview","text":"<p>StreamDingo makes event sourcing simple and reliable by providing:</p> <ul> <li>Clean API: Intuitive event sourcing patterns</li> <li>Hash Integrity: Built-in verification using cryptographic hashes</li> <li>Smart Replay: Efficient snapshot-based event replay</li> <li>High Performance: Optimized for throughput with minimal allocations</li> <li>Type Safety: Strongly typed event handlers and snapshots</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>using StreamDingo;\n\n// Define events\npublic record UserCreated(string Name, string Email);\npublic record UserEmailUpdated(string NewEmail);\n\n// Define state\npublic record UserState(string Name, string Email, bool IsActive = true);\n\n// Create event handlers\npublic class UserEventHandlers\n{\n    public static UserState Apply(UserState? state, UserCreated @event)\n        =&gt; new UserState(@event.Name, @event.Email);\n\n    public static UserState Apply(UserState state, UserEmailUpdated @event)\n        =&gt; state with { Email = @event.NewEmail };\n}\n\n// Use the event store\nvar eventStore = new StreamDingoEventStore();\nvar streamId = Guid.NewGuid();\n\nawait eventStore.AppendAsync(streamId, new UserCreated(\"John Doe\", \"john@example.com\"));\nawait eventStore.AppendAsync(streamId, new UserEmailUpdated(\"john.doe@example.com\"));\n\nvar currentState = await eventStore.ReplayAsync&lt;UserState&gt;(streamId);\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#event-sourcing-made-simple","title":"Event Sourcing Made Simple","text":"<p>Stream events as the single source of truth, with automatic state reconstruction from event history.</p>"},{"location":"#hash-based-integrity","title":"Hash-Based Integrity","text":"<p>Every event handler and snapshot is cryptographically hashed to detect changes and ensure data integrity.</p>"},{"location":"#intelligent-replay","title":"Intelligent Replay","text":"<p>When event order changes or handler code changes, StreamDingo automatically replays from optimal snapshots.</p>"},{"location":"#high-performance","title":"High Performance","text":"<p>Designed for high-throughput scenarios with minimal memory allocations and optimized data structures.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Installation - Add StreamDingo to your project</li> <li>Quick Start - Build your first event-sourced application</li> <li>Basic Concepts - Understand the core principles</li> </ol>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph TD\n    A[Event] --&gt; B[Event Store]\n    B --&gt; C[Event Handler]\n    C --&gt; D[Snapshot]\n    D --&gt; E[Hash Verification]\n    E --&gt; F[Current State]\n\n    G[Code Change] --&gt; H[Hash Mismatch]\n    H --&gt; I[Smart Replay]\n    I --&gt; C</code></pre>"},{"location":"#status","title":"Status","text":"<p>Development Status</p> <p>StreamDingo is currently in active development. The API may change before the first stable release.</p>"},{"location":"#community","title":"Community","text":"<ul> <li>GitHub Repository: alexwiese/StreamDingo</li> <li>Issues &amp; Questions: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> </ul>"},{"location":"#license","title":"License","text":"<p>StreamDingo is licensed under the MIT License.</p>"},{"location":"api-design-principles/","title":"StreamDingo - API Design Principles","text":"<p>Guiding principles for consistent, performant, and user-friendly API design</p>"},{"location":"api-design-principles/#core-philosophy","title":"\ud83c\udfaf Core Philosophy","text":"<p>StreamDingo follows these fundamental principles in all API design decisions:</p> <ol> <li>Simplicity Over Flexibility: Prefer simple, obvious APIs over complex, highly configurable ones</li> <li>Performance by Default: Design for performance without requiring optimization expertise</li> <li>Fail Fast: Validate early and provide clear error messages</li> <li>Async by Design: All I/O operations are async with proper cancellation support</li> <li>Immutable State: Prefer immutable objects and pure functions where possible</li> </ol>"},{"location":"api-design-principles/#api-design-rules","title":"\ud83d\udd27 API Design Rules","text":""},{"location":"api-design-principles/#1-method-naming-conventions","title":"1. Method Naming Conventions","text":""},{"location":"api-design-principles/#async-operations","title":"Async Operations","text":"<ul> <li>All async methods MUST end with <code>Async</code></li> <li>Return <code>ValueTask&lt;T&gt;</code> for potentially synchronous operations</li> <li>Return <code>Task&lt;T&gt;</code> for always asynchronous operations</li> <li>Always accept <code>CancellationToken</code> as the last parameter</li> </ul> <pre><code>// \u2705 Good\nValueTask&lt;Snapshot&lt;T&gt;?&gt; GetLatestSnapshotAsync&lt;T&gt;(string streamId, CancellationToken cancellationToken = default);\n\n// \u274c Bad  \nTask&lt;Snapshot&lt;T&gt;?&gt; GetLatestSnapshot&lt;T&gt;(string streamId);\n</code></pre>"},{"location":"api-design-principles/#sync-operations","title":"Sync Operations","text":"<ul> <li>Avoid synchronous I/O operations</li> <li>Use for pure functions and in-memory operations only</li> <li>Prefer <code>Span&lt;T&gt;</code> and <code>ReadOnlySpan&lt;T&gt;</code> for buffer operations</li> </ul> <pre><code>// \u2705 Good - Pure function\nstring CalculateHash(ReadOnlySpan&lt;byte&gt; data);\n\n// \u274c Bad - I/O operation\nSnapshot&lt;T&gt; GetLatestSnapshot&lt;T&gt;(string streamId);\n</code></pre>"},{"location":"api-design-principles/#2-parameter-design","title":"2. Parameter Design","text":""},{"location":"api-design-principles/#required-parameters","title":"Required Parameters","text":"<ul> <li>Required parameters come first</li> <li>Use descriptive parameter names</li> <li>Avoid <code>object</code> parameters unless absolutely necessary</li> </ul>"},{"location":"api-design-principles/#optional-parameters","title":"Optional Parameters","text":"<ul> <li>Use default parameter values where logical</li> <li>Group related optional parameters into options objects</li> <li>Use nullable types for truly optional values</li> </ul> <pre><code>// \u2705 Good\nValueTask AppendEventAsync&lt;T&gt;(string streamId, T @event, \n    EventAppendOptions? options = null, CancellationToken cancellationToken = default);\n\n// \u274c Bad\nValueTask AppendEventAsync&lt;T&gt;(string streamId, T @event, bool validateHash = true, \n    int timeoutMs = 30000, bool createSnapshot = false, CancellationToken cancellationToken = default);\n</code></pre>"},{"location":"api-design-principles/#3-generic-type-design","title":"3. Generic Type Design","text":""},{"location":"api-design-principles/#type-constraints","title":"Type Constraints","text":"<ul> <li>Use meaningful constraints that communicate intent</li> <li>Prefer interface constraints over class constraints</li> <li>Use <code>where T : class</code> for reference types that can be null</li> </ul> <pre><code>// \u2705 Good\npublic interface IEventHandler&lt;TState, TEvent&gt;\n    where TState : class\n    where TEvent : IEvent\n{\n    TState Handle(TState? previousSnapshot, TEvent @event);\n}\n\n// \u274c Bad\npublic interface IEventHandler&lt;TState, TEvent&gt;\n{\n    TState Handle(TState previousSnapshot, TEvent @event);\n}\n</code></pre>"},{"location":"api-design-principles/#4-exception-handling","title":"4. Exception Handling","text":""},{"location":"api-design-principles/#custom-exceptions","title":"Custom Exceptions","text":"<ul> <li>Create specific exception types for different error scenarios</li> <li>Include relevant context in exception messages</li> <li>Use inner exceptions to preserve stack traces</li> </ul> <pre><code>// \u2705 Good\npublic class EventReplayException : Exception\n{\n    public string StreamId { get; }\n    public long Version { get; }\n\n    public EventReplayException(string streamId, long version, string message, Exception? innerException = null)\n        : base($\"Failed to replay events for stream '{streamId}' at version {version}: {message}\", innerException)\n    {\n        StreamId = streamId;\n        Version = version;\n    }\n}\n\n// \u274c Bad\nthrow new Exception(\"Replay failed\");\n</code></pre>"},{"location":"api-design-principles/#error-communication","title":"Error Communication","text":"<ul> <li>Use Result pattern for expected failures <li>Reserve exceptions for unexpected errors</li> <li>Provide retry guidance in error messages</li>"},{"location":"api-design-principles/#5-configuration-and-options","title":"5. Configuration and Options","text":""},{"location":"api-design-principles/#builder-pattern","title":"Builder Pattern","text":"<ul> <li>Use fluent builder APIs for complex configuration</li> <li>Provide reasonable defaults for all optional settings</li> <li>Validate configuration at build time, not runtime</li> </ul> <pre><code>// \u2705 Good\nvar eventSourcing = EventSourcingBuilder\n    .Create()\n    .UseInMemoryStore()\n    .WithSnapshotInterval(100)\n    .EnableHashVerification()\n    .Build();\n\n// \u274c Bad\nvar options = new EventSourcingOptions\n{\n    StoreType = EventStoreType.InMemory,\n    SnapshotInterval = 100,\n    HashVerificationEnabled = true\n};\nvar eventSourcing = new EventSourcingEngine(options);\n</code></pre>"},{"location":"api-design-principles/#options-classes","title":"Options Classes","text":"<ul> <li>Use record types for immutable options</li> <li>Group related settings together</li> <li>Provide validation methods</li> </ul> <pre><code>// \u2705 Good\npublic record EventSourcingOptions\n{\n    public int SnapshotInterval { get; init; } = 100;\n    public bool EnableHashVerification { get; init; } = true;\n    public TimeSpan EventTimeout { get; init; } = TimeSpan.FromSeconds(30);\n\n    public void Validate()\n    {\n        if (SnapshotInterval &lt;= 0)\n            throw new ArgumentException(\"SnapshotInterval must be positive\", nameof(SnapshotInterval));\n    }\n}\n</code></pre>"},{"location":"api-design-principles/#6-dependency-injection-integration","title":"6. Dependency Injection Integration","text":""},{"location":"api-design-principles/#service-registration","title":"Service Registration","text":"<ul> <li>Provide extension methods for <code>IServiceCollection</code></li> <li>Support both singleton and scoped lifetimes appropriately</li> <li>Allow configuration via <code>IConfiguration</code></li> </ul> <pre><code>// \u2705 Good\npublic static class ServiceCollectionExtensions\n{\n    public static IServiceCollection AddStreamDingo(this IServiceCollection services,\n        Action&lt;EventSourcingBuilder&gt;? configure = null)\n    {\n        var builder = EventSourcingBuilder.Create();\n        configure?.Invoke(builder);\n\n        services.AddSingleton(builder.Build());\n        return services;\n    }\n}\n</code></pre>"},{"location":"api-design-principles/#7-serialization","title":"7. Serialization","text":""},{"location":"api-design-principles/#flexible-serialization","title":"Flexible Serialization","text":"<ul> <li>Support multiple serialization providers</li> <li>Default to System.Text.Json for .NET objects</li> <li>Allow custom serializers for specific types</li> </ul> <pre><code>// \u2705 Good\npublic interface IEventSerializer\n{\n    ReadOnlyMemory&lt;byte&gt; Serialize&lt;T&gt;(T obj) where T : IEvent;\n    T Deserialize&lt;T&gt;(ReadOnlyMemory&lt;byte&gt; data) where T : IEvent;\n    object Deserialize(ReadOnlyMemory&lt;byte&gt; data, Type eventType);\n}\n</code></pre>"},{"location":"api-design-principles/#8-observability-integration","title":"8. Observability Integration","text":""},{"location":"api-design-principles/#logging","title":"Logging","text":"<ul> <li>Use <code>ILogger&lt;T&gt;</code> for all logging</li> <li>Provide structured logging with relevant context</li> <li>Use appropriate log levels</li> </ul> <pre><code>// \u2705 Good  \n_logger.LogInformation(\"Event appended to stream {StreamId} at version {Version}\", \n    streamId, version);\n\n// \u274c Bad\n_logger.LogInformation($\"Event appended to stream {streamId} at version {version}\");\n</code></pre>"},{"location":"api-design-principles/#metrics","title":"Metrics","text":"<ul> <li>Expose key metrics via .NET meters</li> <li>Use consistent naming conventions</li> <li>Provide both counter and histogram metrics</li> </ul> <pre><code>// \u2705 Good\npublic static class StreamDingoMetrics\n{\n    private static readonly Meter Meter = new(\"StreamDingo.EventSourcing\");\n\n    public static readonly Counter&lt;long&gt; EventsAppended = \n        Meter.CreateCounter&lt;long&gt;(\"streamdingo.events.appended\");\n\n    public static readonly Histogram&lt;double&gt; ReplayDuration = \n        Meter.CreateHistogram&lt;double&gt;(\"streamdingo.replay.duration\", \"ms\");\n}\n</code></pre>"},{"location":"api-design-principles/#target-use-cases","title":"\ud83c\udfaf Target Use Cases","text":""},{"location":"api-design-principles/#1-simple-event-sourcing","title":"1. Simple Event Sourcing","text":"<pre><code>// Minimal setup for basic event sourcing\nvar eventSourcing = EventSourcingBuilder\n    .Create()\n    .UseInMemoryStore()\n    .Build();\n\nawait eventSourcing.AppendEventAsync(\"order-123\", new OrderCreated(\"123\", \"John Doe\"));\nvar currentState = await eventSourcing.GetCurrentStateAsync&lt;OrderState&gt;(\"order-123\");\n</code></pre>"},{"location":"api-design-principles/#2-production-event-sourcing","title":"2. Production Event Sourcing","text":"<pre><code>// Full production setup with SQL Server and monitoring\nvar eventSourcing = EventSourcingBuilder\n    .Create()\n    .UseSqlServer(connectionString)\n    .WithSnapshotInterval(500)\n    .EnableHashVerification()\n    .EnableTelemetry()\n    .Build();\n</code></pre>"},{"location":"api-design-principles/#3-custom-event-processing","title":"3. Custom Event Processing","text":"<pre><code>// Custom event handler registration\neventSourcing.RegisterHandler&lt;OrderState, OrderCreated&gt;(new OrderCreatedHandler());\neventSourcing.RegisterHandler&lt;OrderState, OrderShipped&gt;(new OrderShippedHandler());\n</code></pre>"},{"location":"api-design-principles/#backward-compatibility","title":"\ud83d\udee1\ufe0f Backward Compatibility","text":""},{"location":"api-design-principles/#versioning-strategy","title":"Versioning Strategy","text":"<ul> <li>Follow Semantic Versioning (SemVer)</li> <li>Major version for breaking changes</li> <li>Minor version for new features</li> <li>Patch version for bug fixes</li> </ul>"},{"location":"api-design-principles/#api-evolution","title":"API Evolution","text":"<ul> <li>Mark obsolete APIs with <code>[Obsolete]</code> attribute</li> <li>Provide migration path in XML documentation</li> <li>Support old APIs for at least one major version</li> <li>Use <code>#pragma warning disable</code> sparingly</li> </ul>"},{"location":"api-design-principles/#breaking-change-guidelines","title":"Breaking Change Guidelines","text":"<ul> <li>Avoid breaking changes in minor versions</li> <li>Document all breaking changes in release notes</li> <li>Provide automated migration tools where possible</li> <li>Consider feature flags for gradual migration</li> </ul>"},{"location":"api-design-principles/#code-review-checklist","title":"\ud83d\udd0d Code Review Checklist","text":""},{"location":"api-design-principles/#api-design-review","title":"API Design Review","text":"<ul> <li> Method names follow async/sync conventions</li> <li> Parameters are in correct order (required first, cancellation token last)</li> <li> Generic constraints are meaningful and necessary</li> <li> Return types use ValueTask appropriately <li> Exceptions are specific and meaningful</li> <li> XML documentation is complete and accurate</li>"},{"location":"api-design-principles/#performance-review","title":"Performance Review","text":"<ul> <li> No unnecessary allocations in hot paths</li> <li> Proper use of Span and Memory <li> Object pooling considered for frequent allocations</li> <li> Async methods don't block synchronously</li> <li> Cancellation tokens are properly propagated</li>"},{"location":"api-design-principles/#testing-review","title":"Testing Review","text":"<ul> <li> Unit tests cover happy path and edge cases</li> <li> Integration tests validate end-to-end scenarios</li> <li> Performance tests validate targets are met</li> <li> Error handling tests validate exception behavior</li> <li> Async tests properly handle cancellation</li> </ul> <p>Last Updated: $(date) Version: 1.0 Status: Draft</p>"},{"location":"development-environment/","title":"StreamDingo - Development Environment Setup","text":"<p>Complete guide for setting up a StreamDingo development environment</p>"},{"location":"development-environment/#prerequisites","title":"\ud83c\udfaf Prerequisites","text":""},{"location":"development-environment/#required-software","title":"Required Software","text":""},{"location":"development-environment/#net-sdk","title":".NET SDK","text":"<ul> <li>Version: .NET 9.0.304 or later</li> <li>Download: https://dotnet.microsoft.com/download/dotnet/9.0</li> <li>Verification: Run <code>dotnet --version</code> to confirm installation</li> </ul> <pre><code># Install .NET 9.0 SDK (Linux/macOS)\ncurl -sSL https://dot.net/v1/dotnet-install.sh | bash /dev/stdin --channel 9.0 --install-dir ~/.dotnet\nexport PATH=\"$HOME/.dotnet:$PATH\"\n\n# Verify installation\ndotnet --version  # Should show 9.0.304 or later\n</code></pre>"},{"location":"development-environment/#git","title":"Git","text":"<ul> <li>Version: Git 2.30 or later</li> <li>Download: https://git-scm.com/downloads</li> <li>Verification: Run <code>git --version</code> to confirm installation</li> </ul>"},{"location":"development-environment/#recommended-ides","title":"Recommended IDEs","text":""},{"location":"development-environment/#visual-studio-2022-windows","title":"Visual Studio 2022 (Windows)","text":"<ul> <li>Version: 17.8 or later</li> <li>Workload: .NET desktop development</li> <li>Extensions:</li> <li>GitHub Copilot</li> <li>SonarLint for Visual Studio</li> <li>EditorConfig Language Service</li> </ul>"},{"location":"development-environment/#visual-studio-code-cross-platform","title":"Visual Studio Code (Cross-Platform)","text":"<ul> <li>Version: 1.85 or later</li> <li>Extensions:</li> <li>C# Dev Kit</li> <li>GitHub Copilot</li> <li>EditorConfig for VS Code</li> <li>GitLens</li> <li>Coverage Gutters</li> </ul>"},{"location":"development-environment/#jetbrains-rider-cross-platform","title":"JetBrains Rider (Cross-Platform)","text":"<ul> <li>Version: 2023.3 or later</li> <li>Plugins:</li> <li>GitHub Copilot</li> <li>SonarLint</li> <li>Code Coverage</li> </ul>"},{"location":"development-environment/#quick-setup","title":"\ud83d\ude80 Quick Setup","text":""},{"location":"development-environment/#1-clone-repository","title":"1. Clone Repository","text":"<pre><code>git clone https://github.com/alexwiese/StreamDingo.git\ncd StreamDingo\n</code></pre>"},{"location":"development-environment/#2-restore-dependencies","title":"2. Restore Dependencies","text":"<pre><code>dotnet restore\n</code></pre>"},{"location":"development-environment/#3-build-solution","title":"3. Build Solution","text":"<pre><code>dotnet build src/StreamDingo/StreamDingo.csproj\n</code></pre>"},{"location":"development-environment/#4-run-tests","title":"4. Run Tests","text":"<pre><code>dotnet test tests/StreamDingo.Tests/StreamDingo.Tests.csproj\n</code></pre>"},{"location":"development-environment/#5-format-code","title":"5. Format Code","text":"<pre><code>dotnet format\n</code></pre>"},{"location":"development-environment/#development-workflow","title":"\ud83d\udee0\ufe0f Development Workflow","text":""},{"location":"development-environment/#daily-development-commands","title":"Daily Development Commands","text":""},{"location":"development-environment/#build-and-test","title":"Build and Test","text":"<pre><code># Full build and test cycle\ndotnet restore &amp;&amp; dotnet build &amp;&amp; dotnet test\n\n# Quick test run\ndotnet test --no-build\n\n# Build with verbose output for debugging\ndotnet build --verbosity normal\n</code></pre>"},{"location":"development-environment/#code-quality","title":"Code Quality","text":"<pre><code># Format code according to .editorconfig\ndotnet format\n\n# Check formatting without making changes\ndotnet format --verify-no-changes\n\n# Run static analysis (if configured)\ndotnet build --verbosity normal\n</code></pre>"},{"location":"development-environment/#package-creation","title":"Package Creation","text":"<pre><code># Create development package\ndotnet pack src/StreamDingo/StreamDingo.csproj --configuration Debug\n\n# Create release package\ndotnet pack src/StreamDingo/StreamDingo.csproj --configuration Release\n</code></pre>"},{"location":"development-environment/#testing-workflow","title":"Testing Workflow","text":""},{"location":"development-environment/#unit-tests","title":"Unit Tests","text":"<pre><code># Run all tests\ndotnet test\n\n# Run tests with coverage\ndotnet test --collect:\"XPlat Code Coverage\" --results-directory TestResults/\n\n# Run specific test class\ndotnet test --filter \"FullyQualifiedName~StreamDingo.Tests.EventSourcingTests\"\n\n# Run tests with detailed output\ndotnet test --verbosity normal\n</code></pre>"},{"location":"development-environment/#integration-tests","title":"Integration Tests","text":"<pre><code># Run integration tests (when implemented)\ndotnet test --filter \"Category=Integration\"\n\n# Run with specific test settings\ndotnet test --settings tests.runsettings\n</code></pre>"},{"location":"development-environment/#performance-testing","title":"Performance Testing","text":""},{"location":"development-environment/#benchmarks","title":"Benchmarks","text":"<pre><code># Run benchmarks (when implemented)\ndotnet run --project benchmarks/StreamDingo.Benchmarks --configuration Release\n\n# Run specific benchmark category\ndotnet run --project benchmarks/StreamDingo.Benchmarks --configuration Release -- --filter \"*EventAppend*\"\n</code></pre>"},{"location":"development-environment/#project-structure","title":"\ud83d\udd27 Project Structure","text":""},{"location":"development-environment/#solution-layout","title":"Solution Layout","text":"<pre><code>StreamDingo/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 StreamDingo/              # Main library\n\u251c\u2500\u2500 tests/\n\u2502   \u2514\u2500\u2500 StreamDingo.Tests/        # Unit and integration tests\n\u251c\u2500\u2500 benchmarks/\n\u2502   \u2514\u2500\u2500 StreamDingo.Benchmarks/   # Performance benchmarks\n\u251c\u2500\u2500 examples/\n\u2502   \u2514\u2500\u2500 StreamDingo.Examples/     # Usage examples\n\u251c\u2500\u2500 docs/                         # Documentation source\n\u251c\u2500\u2500 plan/                         # Implementation planning\n\u2514\u2500\u2500 assets/                       # Images and diagrams\n</code></pre>"},{"location":"development-environment/#key-configuration-files","title":"Key Configuration Files","text":""},{"location":"development-environment/#globaljson","title":"global.json","text":"<ul> <li>Specifies required .NET SDK version</li> <li>Ensures consistent builds across environments</li> </ul>"},{"location":"development-environment/#editorconfig","title":".editorconfig","text":"<ul> <li>Defines code formatting rules</li> <li>Enforces consistent style across team</li> <li>Integrated with IDE formatting tools</li> </ul>"},{"location":"development-environment/#streamdingoslnx","title":"StreamDingo.slnx","text":"<ul> <li>Modern solution file format</li> <li>Faster loading and better performance</li> <li>Enhanced project dependency management</li> </ul>"},{"location":"development-environment/#testing-framework","title":"\ud83e\uddea Testing Framework","text":""},{"location":"development-environment/#test-technologies","title":"Test Technologies","text":"<ul> <li>xUnit: Primary testing framework</li> <li>FluentAssertions: Readable assertion syntax</li> <li>Moq: Mocking framework for unit tests</li> <li>Coverlet: Code coverage collection</li> <li>BenchmarkDotNet: Performance benchmarking</li> </ul>"},{"location":"development-environment/#test-categories","title":"Test Categories","text":"<pre><code>// Unit tests\n[Fact]\npublic void EventHandler_Should_ProcessEvent()\n{\n    // Arrange, Act, Assert\n}\n\n// Integration tests\n[Fact]\n[Trait(\"Category\", \"Integration\")]\npublic async Task EventStore_Should_PersistEvents()\n{\n    // Full integration test\n}\n\n// Performance tests  \n[Benchmark]\npublic void EventAppend_Performance()\n{\n    // Performance measurement\n}\n</code></pre>"},{"location":"development-environment/#coverage-requirements","title":"Coverage Requirements","text":"<ul> <li>Minimum: 90% line coverage</li> <li>Target: 95% line coverage</li> <li>Critical Paths: 100% coverage required</li> <li>Exclusions: Generated code, trivial properties</li> </ul>"},{"location":"development-environment/#code-quality-tools","title":"\ud83d\udd0d Code Quality Tools","text":""},{"location":"development-environment/#static-analysis","title":"Static Analysis","text":"<ul> <li>Built-in: Roslyn analyzers enabled</li> <li>FxCop: Microsoft.CodeAnalysis.NetAnalyzers</li> <li>Security: Microsoft.CodeAnalysis.BannedApiAnalyzers</li> <li>Performance: Custom analyzers for allocation detection</li> </ul>"},{"location":"development-environment/#code-formatting","title":"Code Formatting","text":"<ul> <li>Tool: <code>dotnet format</code></li> <li>Configuration: <code>.editorconfig</code></li> <li>Enforcement: CI/CD pipeline validation</li> <li>IDE Integration: Format on save recommended</li> </ul>"},{"location":"development-environment/#documentation","title":"Documentation","text":"<ul> <li>XML Comments: Required for all public APIs</li> <li>Style: Microsoft documentation standards</li> <li>Generation: DocFX or similar tool</li> <li>Examples: Include usage examples in XML comments</li> </ul>"},{"location":"development-environment/#cicd-integration","title":"\ud83d\ude80 CI/CD Integration","text":""},{"location":"development-environment/#github-actions-workflows","title":"GitHub Actions Workflows","text":""},{"location":"development-environment/#continuous-integration-ciyml","title":"Continuous Integration (<code>ci.yml</code>)","text":"<ul> <li>Build validation on all pushes and PRs</li> <li>Test execution with coverage reporting</li> <li>Code formatting verification</li> <li>Security vulnerability scanning</li> </ul>"},{"location":"development-environment/#documentation-docsyml","title":"Documentation (<code>docs.yml</code>)","text":"<ul> <li>MkDocs site generation and deployment</li> <li>API documentation building</li> <li>GitHub Pages publishing</li> <li>Link validation and broken link detection</li> </ul>"},{"location":"development-environment/#performance-pr-benchmarkyml","title":"Performance (<code>pr-benchmark.yml</code>)","text":"<ul> <li>Automated benchmark execution on PRs</li> <li>Performance regression detection</li> <li>Benchmark result comparison and reporting</li> <li>Performance trend tracking</li> </ul>"},{"location":"development-environment/#release-releaseyml","title":"Release (<code>release.yml</code>)","text":"<ul> <li>Automated release creation on tags</li> <li>NuGet package publishing</li> <li>Release notes generation</li> <li>Asset upload and distribution</li> </ul>"},{"location":"development-environment/#local-development-integration","title":"Local Development Integration","text":"<pre><code># Simulate CI locally\n./.github/scripts/validate-pr.sh\n\n# Run all checks\ndotnet restore &amp;&amp; dotnet build &amp;&amp; dotnet test &amp;&amp; dotnet format --verify-no-changes\n</code></pre>"},{"location":"development-environment/#debugging-and-troubleshooting","title":"\ud83d\udc1b Debugging and Troubleshooting","text":""},{"location":"development-environment/#common-issues","title":"Common Issues","text":""},{"location":"development-environment/#net-sdk-version-mismatch","title":".NET SDK Version Mismatch","text":"<pre><code># Check current SDK\ndotnet --version\n\n# Check available SDKs  \ndotnet --list-sdks\n\n# Install specific version\ncurl -sSL https://dot.net/v1/dotnet-install.sh | bash /dev/stdin --version 9.0.304\n</code></pre>"},{"location":"development-environment/#build-failures","title":"Build Failures","text":"<pre><code># Clean and rebuild\ndotnet clean &amp;&amp; dotnet restore &amp;&amp; dotnet build\n\n# Verbose build output\ndotnet build --verbosity diagnostic\n\n# Check for package conflicts\ndotnet list package --outdated\n</code></pre>"},{"location":"development-environment/#test-failures","title":"Test Failures","text":"<pre><code># Run specific failing test\ndotnet test --filter \"FullyQualifiedName=StreamDingo.Tests.SpecificTest\"\n\n# Debug test output\ndotnet test --verbosity normal --logger \"console;verbosity=detailed\"\n\n# Collect crash dumps (if tests crash)\ndotnet test --collect:\"Crash Dump\"\n</code></pre>"},{"location":"development-environment/#performance-debugging","title":"Performance Debugging","text":"<pre><code># Profile memory usage\ndotnet-trace collect --providers Microsoft-DotNETCore-SampleProfiler --process-id &lt;PID&gt;\n\n# Analyze garbage collection\ndotnet-trace collect --providers Microsoft-Windows-DotNETRuntime:gc --process-id &lt;PID&gt;\n\n# Monitor allocations\ndotnet-counters monitor --process-id &lt;PID&gt; System.Runtime\n</code></pre>"},{"location":"development-environment/#learning-resources","title":"\ud83d\udcda Learning Resources","text":""},{"location":"development-environment/#event-sourcing-concepts","title":"Event Sourcing Concepts","text":"<ul> <li>Event Sourcing Pattern</li> <li>CQRS and Event Sourcing</li> <li>DDD and Event Sourcing</li> </ul>"},{"location":"development-environment/#net-performance","title":".NET Performance","text":"<ul> <li>.NET Performance Best Practices</li> <li>Memory Management and GC</li> <li>Async Programming Patterns</li> </ul>"},{"location":"development-environment/#testing-and-quality","title":"Testing and Quality","text":"<ul> <li>Unit Testing Best Practices</li> <li>xUnit Documentation</li> <li>FluentAssertions Guide</li> </ul>"},{"location":"development-environment/#development-tips","title":"\ud83c\udfaf Development Tips","text":""},{"location":"development-environment/#performance-best-practices","title":"Performance Best Practices","text":"<ul> <li>Use <code>Span&lt;T&gt;</code> and <code>Memory&lt;T&gt;</code> for buffer operations</li> <li>Avoid <code>async void</code> except for event handlers</li> <li>Use <code>ConfigureAwait(false)</code> in library code</li> <li>Profile regularly with BenchmarkDotNet</li> </ul>"},{"location":"development-environment/#code-organization","title":"Code Organization","text":"<ul> <li>Group related functionality in folders</li> <li>Use meaningful namespace hierarchies</li> <li>Keep classes focused and single-purpose</li> <li>Prefer composition over inheritance</li> </ul>"},{"location":"development-environment/#testing-strategies","title":"Testing Strategies","text":"<ul> <li>Write tests first for complex logic</li> <li>Use descriptive test method names</li> <li>Test both happy path and error scenarios</li> <li>Mock external dependencies appropriately</li> </ul> <p>Last Updated: $(date) Version: 1.0 Status: Complete</p>"},{"location":"technical-specification/","title":"StreamDingo - Technical Specification","text":"<p>Event Sourcing .NET Library with Hash-Based Integrity Verification</p>"},{"location":"technical-specification/#overview","title":"\ud83c\udfaf Overview","text":"<p>StreamDingo is a high-performance .NET library for event sourcing that provides: - Hash-based integrity verification using alexwiese/hashstamp - Snapshot-based event replay for efficient state reconstruction - Intelligent replay optimization when event handlers change - Production-ready performance with minimal allocations</p>"},{"location":"technical-specification/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":""},{"location":"technical-specification/#core-components","title":"Core Components","text":""},{"location":"technical-specification/#1-event-handler-system","title":"1. Event Handler System","text":"<pre><code>public interface IEventHandler&lt;TState, TEvent&gt;\n    where TState : class\n    where TEvent : IEvent\n{\n    TState Handle(TState? previousSnapshot, TEvent @event);\n}\n</code></pre> <p>Key Features: - Pure functions: <code>(previousSnapshot, event) \u2192 newSnapshot</code> - Stateless and deterministic - Hash-verified using hashstamp source generator - Support for both mutable and immutable state objects</p>"},{"location":"technical-specification/#2-event-store-abstraction","title":"2. Event Store Abstraction","text":"<pre><code>public interface IEventStore\n{\n    ValueTask AppendEventAsync&lt;T&gt;(string streamId, T @event, CancellationToken cancellationToken = default)\n        where T : IEvent;\n\n    IAsyncEnumerable&lt;IEvent&gt; ReadEventsAsync(string streamId, long fromVersion = 0, \n        CancellationToken cancellationToken = default);\n\n    ValueTask&lt;Snapshot&lt;T&gt;?&gt; GetLatestSnapshotAsync&lt;T&gt;(string streamId, \n        CancellationToken cancellationToken = default) where T : class;\n\n    ValueTask SaveSnapshotAsync&lt;T&gt;(string streamId, Snapshot&lt;T&gt; snapshot, \n        CancellationToken cancellationToken = default) where T : class;\n}\n</code></pre>"},{"location":"technical-specification/#3-snapshot-management","title":"3. Snapshot Management","text":"<pre><code>public class Snapshot&lt;T&gt; where T : class\n{\n    public string StreamId { get; init; }\n    public long Version { get; init; }\n    public T State { get; init; }\n    public string Hash { get; init; }\n    public DateTime CreatedAt { get; init; }\n    public Dictionary&lt;string, string&gt; HandlerHashes { get; init; }\n}\n</code></pre> <p>Hash Integrity Features: - State Hash: SHA-256 of serialized state data - Handler Hashes: Hash of each event handler's source code - Snapshot Verification: Detect tampering or corruption - Handler Change Detection: Trigger replay when code changes</p>"},{"location":"technical-specification/#4-event-replay-engine","title":"4. Event Replay Engine","text":"<pre><code>public interface IEventReplayEngine\n{\n    ValueTask&lt;T&gt; ReplayEventsAsync&lt;T&gt;(string streamId, \n        CancellationToken cancellationToken = default) where T : class;\n\n    ValueTask&lt;T&gt; ReplayFromSnapshotAsync&lt;T&gt;(string streamId, Snapshot&lt;T&gt; snapshot,\n        CancellationToken cancellationToken = default) where T : class;\n}\n</code></pre> <p>Intelligent Replay Logic: 1. Load latest snapshot 2. Compare handler hashes with current code 3. If hashes match: replay from latest snapshot 4. If hashes differ: find last compatible snapshot or replay from beginning 5. Apply events sequentially using current handlers 6. Create new snapshot when complete</p>"},{"location":"technical-specification/#event-sourcing-flow","title":"Event Sourcing Flow","text":"<pre><code>graph TD\n    A[Append Event] --&gt; B[Load Latest Snapshot]\n    B --&gt; C{Handler Hashes Match?}\n    C --&gt;|Yes| D[Apply Event to Snapshot]\n    C --&gt;|No| E[Find Compatible Snapshot]\n    E --&gt; F{Compatible Found?}\n    F --&gt;|Yes| G[Replay from Compatible Snapshot]\n    F --&gt;|No| H[Replay from Beginning]\n    G --&gt; D\n    H --&gt; D\n    D --&gt; I[Save New Snapshot]\n    I --&gt; J[Update State Hash]\n    J --&gt; K[Store Handler Hashes]</code></pre>"},{"location":"technical-specification/#performance-targets","title":"\ud83d\ude80 Performance Targets","text":""},{"location":"technical-specification/#throughput-targets","title":"Throughput Targets","text":"<ul> <li>Event Append: &gt;100,000 events/second</li> <li>Event Replay: &gt;500,000 events/second  </li> <li>Snapshot Creation: &gt;10,000 snapshots/second</li> <li>Hash Verification: &gt;1,000,000 hashes/second</li> </ul>"},{"location":"technical-specification/#memory-targets","title":"Memory Targets","text":"<ul> <li>1M Events + Snapshots: &lt;1GB memory usage</li> <li>Event Processing: &lt;1KB allocations per event</li> <li>Snapshot Storage: &lt;500MB for 10,000 snapshots</li> <li>Hash Cache: &lt;50MB for 100,000 handler hashes</li> </ul>"},{"location":"technical-specification/#latency-targets","title":"Latency Targets","text":"<ul> <li>Single Event Append: &lt;1ms P99</li> <li>Snapshot Lookup: &lt;0.5ms P99</li> <li>Hash Verification: &lt;0.1ms P99</li> <li>Event Replay: &lt;10ms P99 for 1,000 events</li> </ul>"},{"location":"technical-specification/#api-design-principles","title":"\ud83d\udd27 API Design Principles","text":""},{"location":"technical-specification/#1-simplicity-first","title":"1. Simplicity First","text":"<ul> <li>Minimal configuration required</li> <li>Fluent builder patterns for setup</li> <li>Convention over configuration</li> <li>Clear error messages and exceptions</li> </ul>"},{"location":"technical-specification/#2-performance-optimized","title":"2. Performance Optimized","text":"<ul> <li><code>ValueTask&lt;T&gt;</code> for potentially synchronous operations</li> <li>Object pooling for frequent allocations</li> <li>Span and Memory for buffer management <li>Zero-allocation paths where possible</li>"},{"location":"technical-specification/#3-extensibility","title":"3. Extensibility","text":"<ul> <li>Pluggable event store implementations</li> <li>Custom serialization support</li> <li>Configurable snapshot policies</li> <li>Event transformation and middleware</li> </ul>"},{"location":"technical-specification/#4-production-ready","title":"4. Production Ready","text":"<ul> <li>Comprehensive logging and telemetry</li> <li>Circuit breaker patterns for reliability</li> <li>Retry policies with exponential backoff</li> <li>Health checks and monitoring integration</li> </ul>"},{"location":"technical-specification/#package-structure","title":"\ud83d\udce6 Package Structure","text":""},{"location":"technical-specification/#core-package-streamdingo","title":"Core Package: StreamDingo","text":"<pre><code>StreamDingo/\n\u251c\u2500\u2500 EventSourcing/\n\u2502   \u251c\u2500\u2500 IEvent.cs\n\u2502   \u251c\u2500\u2500 IEventHandler.cs\n\u2502   \u251c\u2500\u2500 IEventStore.cs\n\u2502   \u2514\u2500\u2500 EventReplayEngine.cs\n\u251c\u2500\u2500 Snapshots/\n\u2502   \u251c\u2500\u2500 Snapshot.cs\n\u2502   \u251c\u2500\u2500 ISnapshotStore.cs\n\u2502   \u2514\u2500\u2500 SnapshotManager.cs\n\u251c\u2500\u2500 Integrity/\n\u2502   \u251c\u2500\u2500 IHashProvider.cs\n\u2502   \u251c\u2500\u2500 HashStampIntegration.cs\n\u2502   \u2514\u2500\u2500 IntegrityVerifier.cs\n\u2514\u2500\u2500 Configuration/\n    \u251c\u2500\u2500 StreamDingoOptions.cs\n    \u2514\u2500\u2500 EventSourcingBuilder.cs\n</code></pre>"},{"location":"technical-specification/#storage-providers-separate-packages","title":"Storage Providers (Separate Packages)","text":"<ul> <li>StreamDingo.SqlServer: SQL Server provider</li> <li>StreamDingo.PostgreSQL: PostgreSQL provider  </li> <li>StreamDingo.InMemory: In-memory provider for testing</li> <li>StreamDingo.FileSystem: File-based provider for simple scenarios</li> </ul>"},{"location":"technical-specification/#integration-with-hashstamp","title":"\ud83d\udd04 Integration with HashStamp","text":""},{"location":"technical-specification/#setup-integration","title":"Setup Integration","text":"<pre><code>// In StreamDingo.csproj\n&lt;PackageReference Include=\"HashStamp\" Version=\"1.0.0\" PrivateAssets=\"analyzers\" /&gt;\n</code></pre>"},{"location":"technical-specification/#usage-pattern","title":"Usage Pattern","text":"<pre><code>// Event handlers automatically get hashes generated\npublic class OrderEventHandler : IEventHandler&lt;OrderState, OrderCreated&gt;\n{\n    public OrderState Handle(OrderState? previous, OrderCreated @event)\n    {\n        // Method body hash: HashStamps.OrderEventHandler.Handle\n        return new OrderState \n        { \n            Id = @event.OrderId, \n            Status = \"Created\" \n        };\n    }\n}\n\n// Integrity verification\nvar currentHash = HashStamps.OrderEventHandler.Handle;\nvar snapshotHash = snapshot.HandlerHashes[\"OrderEventHandler.Handle\"];\nvar needsReplay = currentHash != snapshotHash;\n</code></pre>"},{"location":"technical-specification/#use-cases-and-user-personas","title":"\ud83d\udcca Use Cases and User Personas","text":""},{"location":"technical-specification/#primary-use-cases","title":"Primary Use Cases","text":"<ol> <li>Financial Transaction Systems</li> <li>Audit trails for regulatory compliance</li> <li>Event replay for transaction verification</li> <li> <p>State reconstruction for balance calculations</p> </li> <li> <p>E-commerce Order Management</p> </li> <li>Order lifecycle tracking</li> <li>Inventory state management</li> <li> <p>Customer interaction history</p> </li> <li> <p>IoT Data Processing</p> </li> <li>Sensor data aggregation</li> <li>Device state tracking</li> <li> <p>Historical data analysis</p> </li> <li> <p>Domain Event Systems</p> </li> <li>Microservice communication</li> <li>CQRS implementation</li> <li>Distributed system coordination</li> </ol>"},{"location":"technical-specification/#user-personas","title":"User Personas","text":""},{"location":"technical-specification/#1-enterprise-developer","title":"1. Enterprise Developer","text":"<ul> <li>Needs: Reliable, well-documented, production-ready</li> <li>Priorities: Performance, security, compliance</li> <li>Pain Points: Complex setup, poor documentation</li> </ul>"},{"location":"technical-specification/#2-startup-developer","title":"2. Startup Developer","text":"<ul> <li>Needs: Quick setup, flexible, cost-effective</li> <li>Priorities: Rapid development, scalability</li> <li>Pain Points: Over-engineering, expensive licenses</li> </ul>"},{"location":"technical-specification/#3-open-source-contributor","title":"3. Open Source Contributor","text":"<ul> <li>Needs: Clean code, good test coverage, clear contribution guidelines</li> <li>Priorities: Code quality, learning opportunities</li> <li>Pain Points: Poor project structure, lack of tests</li> </ul>"},{"location":"technical-specification/#success-metrics","title":"\ud83c\udfaf Success Metrics","text":""},{"location":"technical-specification/#technical-metrics","title":"Technical Metrics","text":"<ul> <li>Test Coverage: &gt;90% line coverage</li> <li>Performance: Meet all latency and throughput targets</li> <li>Memory: Zero detectable memory leaks</li> <li>Security: Zero high-severity vulnerabilities</li> </ul>"},{"location":"technical-specification/#community-metrics","title":"Community Metrics","text":"<ul> <li>GitHub Stars: &gt;100 within 3 months</li> <li>NuGet Downloads: &gt;1,000 within 6 months</li> <li>Community PRs: &gt;5 external contributions</li> <li>Issue Response: &lt;48 hours average response time</li> </ul>"},{"location":"technical-specification/#quality-metrics","title":"Quality Metrics","text":"<ul> <li>Documentation: 100% public API documented</li> <li>Examples: &gt;5 comprehensive usage examples</li> <li>Breaking Changes: &lt;1 per major version</li> <li>Bug Reports: &lt;10 open bugs at any time</li> </ul>"},{"location":"technical-specification/#security-considerations","title":"\ud83d\udd12 Security Considerations","text":""},{"location":"technical-specification/#hash-integrity","title":"Hash Integrity","text":"<ul> <li>SHA-256 for all hash calculations</li> <li>Collision detection and handling</li> <li>Secure hash storage and transmission</li> <li>Protection against hash manipulation</li> </ul>"},{"location":"technical-specification/#data-protection","title":"Data Protection","text":"<ul> <li>Optional encryption for sensitive events</li> <li>Secure snapshot storage</li> <li>Audit trail protection</li> <li>GDPR compliance considerations</li> </ul>"},{"location":"technical-specification/#access-control","title":"Access Control","text":"<ul> <li>Event store access controls</li> <li>Snapshot access permissions</li> <li>Administrative operation restrictions</li> <li>API rate limiting capabilities</li> </ul>"},{"location":"technical-specification/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"technical-specification/#unit-testing-90-coverage","title":"Unit Testing (&gt;90% Coverage)","text":"<ul> <li>Event handler registration and execution</li> <li>Snapshot creation and validation</li> <li>Hash calculation and verification</li> <li>Error handling and edge cases</li> <li>Serialization and deserialization</li> </ul>"},{"location":"technical-specification/#integration-testing","title":"Integration Testing","text":"<ul> <li>End-to-end event sourcing scenarios</li> <li>Storage provider integration</li> <li>Concurrency and thread safety</li> <li>Performance under load</li> <li>Data corruption recovery</li> </ul>"},{"location":"technical-specification/#performance-testing","title":"Performance Testing","text":"<ul> <li>Throughput benchmarks</li> <li>Memory allocation profiling</li> <li>Latency measurements</li> <li>Stress testing scenarios</li> <li>Scalability validation</li> </ul>"},{"location":"technical-specification/#monitoring-and-observability","title":"\ud83d\udcc8 Monitoring and Observability","text":""},{"location":"technical-specification/#metrics","title":"Metrics","text":"<ul> <li>Event processing rates</li> <li>Snapshot creation frequency</li> <li>Hash verification timing</li> <li>Memory usage patterns</li> <li>Error rates and types</li> </ul>"},{"location":"technical-specification/#logging","title":"Logging","text":"<ul> <li>Structured logging with Serilog</li> <li>Correlation IDs for request tracking</li> <li>Performance counters</li> <li>Error details and stack traces</li> <li>Debug information for development</li> </ul>"},{"location":"technical-specification/#health-checks","title":"Health Checks","text":"<ul> <li>Event store connectivity</li> <li>Snapshot store accessibility</li> <li>Hash verification integrity</li> <li>Memory usage thresholds</li> <li>Performance degradation detection</li> </ul> <p>Last Updated: $(date) Version: 1.0 Status: Draft</p>"},{"location":"advanced/benchmarks/","title":"Benchmarks","text":"<p>StreamDingo uses BenchmarkDotNet to measure and track performance characteristics across different scenarios.</p>"},{"location":"advanced/benchmarks/#running-benchmarks","title":"Running Benchmarks","text":""},{"location":"advanced/benchmarks/#local-development","title":"Local Development","text":"<p>To run benchmarks locally:</p> <pre><code>cd benchmarks/StreamDingo.Benchmarks\ndotnet run --configuration Release\n</code></pre> <p>For specific benchmarks:</p> <pre><code>dotnet run --configuration Release -- --filter \"*EventAppend*\"\n</code></pre>"},{"location":"advanced/benchmarks/#benchmark-categories","title":"Benchmark Categories","text":"<p>The benchmark suite covers:</p> <ul> <li>Event Appending: Throughput of adding events to streams</li> <li>Event Replay: Speed of reconstructing state from events</li> <li>Hash Calculation: Performance of integrity verification</li> <li>Snapshot Creation: Memory and time costs of snapshots</li> <li>Memory Allocation: GC pressure and memory usage patterns</li> </ul>"},{"location":"advanced/benchmarks/#automated-performance-tracking","title":"Automated Performance Tracking","text":""},{"location":"advanced/benchmarks/#pr-benchmarks","title":"PR Benchmarks","text":"<p>Every pull request automatically:</p> <ol> <li>Runs baseline benchmarks on the main branch</li> <li>Runs PR benchmarks on the proposed changes</li> <li>Compares results and calculates performance deltas</li> <li>Updates PR description with collapsible performance results</li> <li>Comments on significant changes (&gt;10% regression/improvement)</li> </ol>"},{"location":"advanced/benchmarks/#benchmark-reports","title":"Benchmark Reports","text":"<p>Performance reports include:</p> <pre><code>## \ud83d\udcca Performance Benchmark Results\n\n| Benchmark | Main | PR | Change | Memory Main | Memory PR | Memory Change |\n|-----------|------|----|---------|-----------|---------|-----------   |\n| AppendEvents(100) | 124.3 \u03bcs | 118.2 \u03bcs | \ud83d\udfe2 -4.9% | 2.1 KB | 2.0 KB | \ud83d\udfe2 -4.8% |\n| ReplayEvents(1000) | 1.2 ms | 1.3 ms | \ud83d\udd34 +8.3% | 15.2 KB | 16.1 KB | \ud83d\udfe1 +5.9% |\n</code></pre> <p>Legend: - \ud83d\udfe2 = Performance improvement - \ud83d\udfe1 = Minor change (&lt;10%) - \ud83d\udd34 = Performance regression</p>"},{"location":"advanced/benchmarks/#historical-tracking","title":"Historical Tracking","text":"<p>Benchmark results are: - Stored as artifacts for 30 days - Tracked in GitHub Issues for significant changes - Used to build performance trend reports</p>"},{"location":"advanced/benchmarks/#benchmark-infrastructure","title":"Benchmark Infrastructure","text":""},{"location":"advanced/benchmarks/#benchmarkdotnet-configuration","title":"BenchmarkDotNet Configuration","text":"<pre><code>[MemoryDiagnoser]\n[Orderer(SummaryOrderPolicy.FastestToSlowest)]\n[RankColumn]\npublic class EventSourcingBenchmarks\n{\n    [Benchmark]\n    [Arguments(100, 1000, 10000)]\n    public void AppendEvents(int eventCount) { /* ... */ }\n}\n</code></pre>"},{"location":"advanced/benchmarks/#continuous-integration","title":"Continuous Integration","text":"<p>The benchmark workflow:</p> <ol> <li>Triggers: On every PR to main branch</li> <li>Environment: Ubuntu Latest with .NET 9.0</li> <li>Execution: Short job profile for CI speed</li> <li>Output: JSON format for automated parsing</li> <li>Analysis: Python script for comparison and reporting</li> </ol>"},{"location":"advanced/benchmarks/#skipping-benchmarks","title":"Skipping Benchmarks","text":"<p>To skip benchmarks on a PR (for documentation-only changes):</p> <pre><code>Add the label: skip-benchmark\n</code></pre>"},{"location":"advanced/benchmarks/#interpreting-results","title":"Interpreting Results","text":""},{"location":"advanced/benchmarks/#understanding-metrics","title":"Understanding Metrics","text":"<ul> <li>Mean: Average execution time</li> <li>Median: 50<sup>th</sup> percentile execution time</li> <li>StdDev: Standard deviation (consistency indicator)</li> <li>Allocated: Memory allocated per operation</li> </ul>"},{"location":"advanced/benchmarks/#performance-thresholds","title":"Performance Thresholds","text":"<ul> <li>Green (Improvement): &gt;5% faster or less memory</li> <li>Yellow (Neutral): \u00b15% change</li> <li>Red (Regression): &gt;5% slower or more memory</li> </ul>"},{"location":"advanced/benchmarks/#when-to-be-concerned","title":"When to Be Concerned","text":"<p>Review carefully if: - Core operations show &gt;10% regression - Memory usage increases significantly - New allocations appear in hot paths - Standard deviation increases (less consistent performance)</p>"},{"location":"advanced/benchmarks/#contributing-to-benchmarks","title":"Contributing to Benchmarks","text":"<p>When adding new features:</p> <ol> <li>Add corresponding benchmarks for new operations</li> <li>Ensure benchmarks are realistic and representative</li> <li>Include both best-case and worst-case scenarios</li> <li>Test with different data sizes using <code>[Arguments]</code></li> <li>Verify benchmarks pass before submitting PR</li> </ol>"},{"location":"advanced/benchmarks/#benchmark-best-practices","title":"Benchmark Best Practices","text":"<pre><code>[GlobalSetup]\npublic void Setup()\n{\n    // Initialize test data once\n    // Avoid setup work in benchmark methods\n}\n\n[Benchmark]\npublic void MyBenchmark()\n{\n    // Keep benchmark focused\n    // Avoid external dependencies\n    // Use realistic data sizes\n}\n</code></pre>"},{"location":"advanced/custom-providers/","title":"Custom Storage Providers","text":"<p>Learn how to implement custom storage providers for StreamDingo.</p>"},{"location":"advanced/custom-providers/#implementation-guide","title":"Implementation Guide","text":""},{"location":"advanced/custom-providers/#event-store-provider","title":"Event Store Provider","text":"<p>Implement the <code>IEventStore</code> interface:</p> <pre><code>public interface IEventStore\n{\n    Task AppendEventsAsync(string streamId, IEnumerable&lt;object&gt; events);\n    Task&lt;IEnumerable&lt;object&gt;&gt; GetEventsAsync(string streamId, long fromVersion = 0);\n}\n</code></pre>"},{"location":"advanced/custom-providers/#snapshot-store-provider","title":"Snapshot Store Provider","text":"<p>Implement the <code>ISnapshotStore</code> interface:</p> <pre><code>public interface ISnapshotStore\n{\n    Task SaveSnapshotAsync&lt;T&gt;(string streamId, Snapshot&lt;T&gt; snapshot);\n    Task&lt;Snapshot&lt;T&gt;?&gt; GetSnapshotAsync&lt;T&gt;(string streamId);\n}\n</code></pre>"},{"location":"advanced/custom-providers/#best-practices","title":"Best Practices","text":"<ol> <li>Implement proper error handling</li> <li>Use connection pooling for database providers</li> <li>Consider transaction boundaries</li> <li>Implement retry policies for transient failures</li> <li>Add comprehensive logging</li> </ol>"},{"location":"advanced/custom-providers/#examples","title":"Examples","text":"<p>Complete examples and detailed implementation guides coming soon.</p>"},{"location":"advanced/migrations/","title":"Migration Strategies","text":"<p>Strategies for handling schema changes and system evolution in event-sourced systems.</p>"},{"location":"advanced/migrations/#event-schema-evolution","title":"Event Schema Evolution","text":""},{"location":"advanced/migrations/#versioned-events","title":"Versioned Events","text":"<p>Use versioned events to handle schema changes:</p> <pre><code>public record UserCreatedV1(string UserId, string Name, string Email);\npublic record UserCreatedV2(string UserId, string Name, string Email, string PhoneNumber);\n</code></pre>"},{"location":"advanced/migrations/#migration-handlers","title":"Migration Handlers","text":"<p>Create handlers to migrate between versions:</p> <pre><code>public static UserCreatedV2 Migrate(UserCreatedV1 oldEvent)\n{\n    return new UserCreatedV2(\n        oldEvent.UserId,\n        oldEvent.Name, \n        oldEvent.Email,\n        PhoneNumber: null // Default for new field\n    );\n}\n</code></pre>"},{"location":"advanced/migrations/#aggregate-evolution","title":"Aggregate Evolution","text":""},{"location":"advanced/migrations/#backward-compatibility","title":"Backward Compatibility","text":"<p>Design aggregates to handle old event versions:</p> <pre><code>public static UserAggregate Handle(UserAggregate? state, UserCreatedV1 @event)\n{\n    return new UserAggregate(\n        @event.UserId,\n        @event.Name,\n        @event.Email,\n        PhoneNumber: null, // Handle missing field\n        Version: (state?.Version ?? 0) + 1\n    );\n}\n</code></pre>"},{"location":"advanced/migrations/#forward-compatibility","title":"Forward Compatibility","text":"<p>Consider future changes when designing events:</p> <pre><code>public record UserCreated(\n    string UserId,\n    string Name, \n    string Email,\n    Dictionary&lt;string, object&gt;? ExtensionData = null // For future fields\n);\n</code></pre>"},{"location":"advanced/migrations/#best-practices","title":"Best Practices","text":"<ol> <li>Never delete events - Mark as deprecated instead</li> <li>Add new fields as optional - Use nullable types or default values</li> <li>Version your events - Use clear versioning schemes</li> <li>Test migrations thoroughly - Validate all migration paths</li> <li>Keep migration logic simple - Minimize complexity in migration handlers</li> </ol> <p>More detailed migration strategies and examples coming soon.</p>"},{"location":"advanced/performance/","title":"Performance","text":"<p>StreamDingo is designed for high-performance event sourcing scenarios with careful attention to memory allocations and throughput.</p>"},{"location":"advanced/performance/#performance-targets","title":"Performance Targets","text":"Operation Target Performance Event Append &gt;100,000 events/second Event Replay &gt;500,000 events/second Memory Usage &lt;1GB for 1M events with snapshots Latency (P99) &lt;1ms for single operations"},{"location":"advanced/performance/#benchmarks","title":"Benchmarks","text":"<p>StreamDingo includes a comprehensive benchmark suite using BenchmarkDotNet. You can run the benchmarks to see performance on your hardware:</p> <pre><code>cd benchmarks/StreamDingo.Benchmarks\ndotnet run --configuration Release\n</code></pre>"},{"location":"advanced/performance/#performance-tips","title":"Performance Tips","text":""},{"location":"advanced/performance/#event-design","title":"Event Design","text":"<ul> <li>Keep events small and focused</li> <li>Use value types where possible</li> <li>Avoid deep object hierarchies in events</li> </ul>"},{"location":"advanced/performance/#handler-optimization","title":"Handler Optimization","text":"<ul> <li>Make event handlers pure functions</li> <li>Avoid expensive operations in handlers</li> <li>Use immutable data structures</li> </ul>"},{"location":"advanced/performance/#storage-considerations","title":"Storage Considerations","text":"<ul> <li>Choose appropriate storage providers for your use case</li> <li>Consider using snapshot intervals to balance replay speed vs storage</li> <li>Monitor memory usage with large event streams</li> </ul>"},{"location":"advanced/performance/#monitoring-performance","title":"Monitoring Performance","text":""},{"location":"advanced/performance/#memory-profiling","title":"Memory Profiling","text":"<p>Use tools like: - dotMemory - PerfView - Application Insights</p>"},{"location":"advanced/performance/#throughput-monitoring","title":"Throughput Monitoring","text":"<ul> <li>Track events per second metrics</li> <li>Monitor replay times</li> <li>Set up alerts for performance regressions</li> </ul>"},{"location":"advanced/performance/#continuous-performance-testing","title":"Continuous Performance Testing","text":"<p>StreamDingo includes automated performance regression detection in CI/CD. Each pull request automatically:</p> <ol> <li>Runs benchmarks on the PR branch</li> <li>Compares against the main branch baseline</li> <li>Reports performance changes in the PR description</li> <li>Flags significant regressions for review</li> </ol> <p>See Benchmarks for more details on the benchmark infrastructure.</p>"},{"location":"api/event-store/","title":"Event Store API","text":"<p>Documentation for the Event Store API will be auto-generated from XML comments.</p>"},{"location":"api/hash-provider/","title":"Hash Provider API","text":"<p>Documentation for the Hash Provider API will be auto-generated from XML comments.</p>"},{"location":"api/interfaces/","title":"Core Interfaces","text":"<p>StreamDingo's core interfaces provide the foundation for event sourcing functionality.</p>"},{"location":"api/interfaces/#ievent","title":"IEvent","text":"<p>Base interface for all events in the system.</p>"},{"location":"api/interfaces/#ieventhandler","title":"IEventHandler <p>Defines event handlers that transform aggregate state.</p>","text":""},{"location":"api/interfaces/#ieventstore","title":"IEventStore <p>Manages event persistence and retrieval.</p>","text":""},{"location":"api/interfaces/#isnapshotstore","title":"ISnapshotStore <p>Handles snapshot storage and retrieval.</p>","text":""},{"location":"api/interfaces/#ihashprovider","title":"IHashProvider <p>Provides hash-based integrity verification.</p> <p>More detailed API documentation will be generated automatically from XML comments in the source code.</p>","text":""},{"location":"api/snapshot-store/","title":"Snapshot Store API","text":"<p>Documentation for the Snapshot Store API will be auto-generated from XML comments.</p>"},{"location":"contributing/code-of-conduct/","title":"Code of Conduct","text":""},{"location":"contributing/code-of-conduct/#our-pledge","title":"Our Pledge","text":"<p>We pledge to make participation in our project a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity, level of experience, nationality, personal appearance, race, religion, or sexual identity.</p>"},{"location":"contributing/code-of-conduct/#our-standards","title":"Our Standards","text":"<p>Positive behaviors: - Using welcoming and inclusive language - Being respectful of differing viewpoints - Gracefully accepting constructive criticism - Focusing on what is best for the community - Showing empathy towards other community members</p> <p>Unacceptable behaviors: - Harassment of any kind - Discriminatory language or actions - Personal attacks or insults - Publishing private information without permission - Other conduct inappropriate in a professional setting</p>"},{"location":"contributing/code-of-conduct/#enforcement","title":"Enforcement","text":"<p>Project maintainers are responsible for clarifying standards and taking appropriate corrective action in response to unacceptable behavior.</p>"},{"location":"contributing/code-of-conduct/#reporting","title":"Reporting","text":"<p>Report unacceptable behavior by contacting the project team. All complaints will be reviewed and investigated confidentially.</p>"},{"location":"contributing/code-of-conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1.</p>"},{"location":"contributing/guidelines/","title":"Contribution Guidelines","text":"<p>Thank you for your interest in contributing to StreamDingo!</p>"},{"location":"contributing/guidelines/#how-to-contribute","title":"How to Contribute","text":"<ol> <li>Fork the repository on GitHub</li> <li>Create a feature branch from main</li> <li>Make your changes following our coding standards</li> <li>Add tests for new functionality</li> <li>Update documentation if needed</li> <li>Submit a pull request</li> </ol>"},{"location":"contributing/guidelines/#code-review-process","title":"Code Review Process","text":"<ol> <li>All PRs require review from maintainers</li> <li>Automated tests must pass</li> <li>Code coverage should not decrease</li> <li>Documentation must be updated for new features</li> </ol>"},{"location":"contributing/guidelines/#coding-standards","title":"Coding Standards","text":"<ul> <li>Follow .NET naming conventions</li> <li>Use meaningful variable and method names</li> <li>Add XML documentation for public APIs</li> <li>Keep methods focused and concise</li> <li>Use immutable data structures where possible</li> </ul>"},{"location":"contributing/guidelines/#testing-requirements","title":"Testing Requirements","text":"<ul> <li>Unit tests for all public APIs</li> <li>Integration tests for complex workflows</li> <li>Performance tests for critical paths</li> <li>Test coverage above 90%</li> </ul>"},{"location":"contributing/guidelines/#documentation","title":"Documentation","text":"<ul> <li>Update relevant documentation</li> <li>Add code examples for new features</li> <li>Keep API documentation up to date</li> <li>Update changelog for significant changes</li> </ul>"},{"location":"contributing/guidelines/#getting-help","title":"Getting Help","text":"<ul> <li>Open an issue for questions</li> <li>Join discussions in existing issues</li> <li>Ask in the community forums</li> </ul> <p>More detailed guidelines coming soon.</p>"},{"location":"contributing/security/","title":"Security Policy","text":""},{"location":"contributing/security/#reporting-security-vulnerabilities","title":"Reporting Security Vulnerabilities","text":"<p>We take security seriously. If you discover a security vulnerability in StreamDingo, please report it privately.</p>"},{"location":"contributing/security/#how-to-report","title":"How to Report","text":"<p>Do NOT create a public GitHub issue for security vulnerabilities.</p> <p>Instead, please:</p> <ol> <li>Email security concerns to: [security@alexwiese.io]</li> <li>Include a detailed description of the vulnerability</li> <li>Provide steps to reproduce if possible</li> <li>Allow reasonable time for response before public disclosure</li> </ol>"},{"location":"contributing/security/#what-to-include","title":"What to Include","text":"<p>When reporting security issues, please include:</p> <ul> <li>Description of the vulnerability</li> <li>Steps to reproduce the issue</li> <li>Potential impact assessment</li> <li>Any suggested fixes (if available)</li> <li>Your contact information</li> </ul>"},{"location":"contributing/security/#response-process","title":"Response Process","text":"<ol> <li>Acknowledgment within 48 hours</li> <li>Initial assessment within 7 days</li> <li>Status updates every 7 days until resolved</li> <li>Coordinated disclosure after fix is available</li> </ol>"},{"location":"contributing/security/#security-best-practices","title":"Security Best Practices","text":"<p>When using StreamDingo:</p> <ul> <li>Keep dependencies up to date</li> <li>Use secure connection strings</li> <li>Implement proper access controls</li> <li>Monitor for suspicious activity</li> <li>Follow principle of least privilege</li> </ul>"},{"location":"contributing/security/#supported-versions","title":"Supported Versions","text":"<p>Security updates are provided for:</p> <ul> <li>Latest major version</li> <li>Previous major version (for 12 months after new release)</li> </ul>"},{"location":"contributing/security/#thanks","title":"Thanks","text":"<p>We appreciate the security research community's efforts to help keep StreamDingo secure.</p>"},{"location":"contributing/setup/","title":"Development Setup","text":"<p>Set up your development environment for contributing to StreamDingo.</p>"},{"location":"contributing/setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>.NET 9.0 SDK or later</li> <li>Git</li> <li>Your preferred IDE (Visual Studio 2022, VS Code, or JetBrains Rider)</li> </ul>"},{"location":"contributing/setup/#getting-started","title":"Getting Started","text":"<ol> <li> <p>Clone the repository <pre><code>git clone https://github.com/alexwiese/StreamDingo.git\ncd StreamDingo\n</code></pre></p> </li> <li> <p>Restore dependencies <pre><code>dotnet restore\n</code></pre></p> </li> <li> <p>Build the solution <pre><code>dotnet build\n</code></pre></p> </li> <li> <p>Run tests <pre><code>dotnet test\n</code></pre></p> </li> </ol>"},{"location":"contributing/setup/#development-workflow","title":"Development Workflow","text":"<ol> <li>Create a feature branch</li> <li>Make your changes</li> <li>Run tests and ensure they pass</li> <li>Submit a pull request</li> </ol>"},{"location":"contributing/setup/#project-structure","title":"Project Structure","text":"<ul> <li><code>src/StreamDingo/</code> - Main library code</li> <li><code>tests/StreamDingo.Tests/</code> - Unit and integration tests  </li> <li><code>docs/</code> - Documentation source</li> <li><code>examples/</code> - Usage examples and samples</li> </ul>"},{"location":"contributing/setup/#code-style","title":"Code Style","text":"<ul> <li>Follow .NET coding conventions</li> <li>Use EditorConfig settings (already configured)</li> <li>Run <code>dotnet format</code> before committing</li> <li>Add XML documentation comments for public APIs</li> </ul>"},{"location":"contributing/setup/#testing","title":"Testing","text":"<ul> <li>Write unit tests for new functionality</li> <li>Ensure existing tests continue to pass</li> <li>Add integration tests for complex scenarios</li> <li>Maintain test coverage above 90%</li> </ul> <p>More detailed setup instructions coming soon.</p>"},{"location":"getting-started/concepts/","title":"Basic Concepts","text":"<p>Understanding the core concepts of StreamDingo will help you build robust event-sourced applications.</p>"},{"location":"getting-started/concepts/#event-sourcing-fundamentals","title":"Event Sourcing Fundamentals","text":""},{"location":"getting-started/concepts/#events","title":"Events","text":"<p>Events are immutable records of things that have happened in your system. In StreamDingo, events should be:</p> <ul> <li>Immutable: Once created, events never change</li> <li>Descriptive: Event names should describe what happened in past tense</li> <li>Minimal: Include only the data necessary to represent the change</li> </ul> <pre><code>// Good: Descriptive and minimal\npublic record OrderPlaced(string OrderId, string CustomerId, decimal Amount, DateTime PlacedAt);\n\n// Avoid: Present tense or overly generic\npublic record PlaceOrder(string OrderId, string CustomerId, decimal Amount);\n</code></pre>"},{"location":"getting-started/concepts/#aggregates","title":"Aggregates","text":"<p>Aggregates represent the current state of your domain entities, built by applying a sequence of events:</p> <pre><code>public record OrderAggregate(\n    string Id,\n    string CustomerId, \n    decimal Amount,\n    OrderStatus Status,\n    int Version\n);\n</code></pre>"},{"location":"getting-started/concepts/#event-handlers","title":"Event Handlers","text":"<p>Event handlers are pure functions that take the current aggregate state and an event, returning the new state:</p> <pre><code>public static OrderAggregate Handle(OrderAggregate? state, OrderPlaced @event)\n    =&gt; new(@event.OrderId, @event.CustomerId, @event.Amount, OrderStatus.Placed, (state?.Version ?? 0) + 1);\n</code></pre>"},{"location":"getting-started/concepts/#streamdingo-specific-concepts","title":"StreamDingo Specific Concepts","text":""},{"location":"getting-started/concepts/#hash-based-integrity","title":"Hash-Based Integrity","text":"<p>StreamDingo uses the alexwiese/hashstamp library to ensure integrity:</p> <ul> <li>Event Handler Hashing: Detects when handler logic changes</li> <li>Snapshot Hashing: Verifies snapshot data hasn't been tampered with</li> <li>Event Hashing: Ensures events haven't been modified</li> </ul>"},{"location":"getting-started/concepts/#snapshots","title":"Snapshots","text":"<p>Snapshots are cached aggregate states that improve replay performance:</p> <ul> <li>Created automatically at configurable intervals</li> <li>Include hash verification for data integrity</li> <li>Enable efficient replay from intermediate points</li> <li>Reduce the need to replay all events from the beginning</li> </ul>"},{"location":"getting-started/concepts/#event-replay","title":"Event Replay","text":"<p>When changes are detected, StreamDingo intelligently replays events:</p> <ul> <li>Handler Changes: Replay events affected by handler logic changes</li> <li>Snapshot Corruption: Replay from the last valid snapshot</li> <li>Order Changes: Replay when event ordering is modified</li> </ul>"},{"location":"getting-started/concepts/#event-stream-architecture","title":"Event Stream Architecture","text":"<pre><code>graph TB\n    A[Events] --&gt; B[Event Store]\n    B --&gt; C[Event Replay Engine]\n    C --&gt; D[Event Handlers]\n    D --&gt; E[Snapshots]\n    E --&gt; F[Current State]\n\n    G[Hash Provider] --&gt; D\n    G --&gt; E\n    H[Snapshot Store] --&gt; E</code></pre>"},{"location":"getting-started/concepts/#event-store","title":"Event Store","text":"<ul> <li>Persists events in ordered streams</li> <li>Supports multiple storage providers (In-Memory, SQL Server, PostgreSQL)</li> <li>Ensures event ordering and consistency</li> </ul>"},{"location":"getting-started/concepts/#snapshot-store","title":"Snapshot Store","text":"<ul> <li>Stores aggregate snapshots with hash verification</li> <li>Enables fast state reconstruction</li> <li>Automatic cleanup of old snapshots</li> </ul>"},{"location":"getting-started/concepts/#hash-provider","title":"Hash Provider","text":"<ul> <li>Generates and verifies hashes for integrity checking</li> <li>Integrates with alexwiese/hashstamp library</li> <li>Detects code changes and data corruption</li> </ul>"},{"location":"getting-started/concepts/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/concepts/#event-design","title":"Event Design","text":"<ol> <li>Use past tense: <code>OrderPlaced</code> not <code>PlaceOrder</code></li> <li>Be specific: <code>PaymentProcessed</code> not <code>OrderUpdated</code></li> <li>Include context: Add relevant timestamps and user information</li> </ol>"},{"location":"getting-started/concepts/#handler-design","title":"Handler Design","text":"<ol> <li>Keep handlers pure: No side effects or external dependencies</li> <li>Handle nulls: First event should handle null previous state</li> <li>Version tracking: Always increment version numbers</li> </ol>"},{"location":"getting-started/concepts/#aggregate-design","title":"Aggregate Design","text":"<ol> <li>Include version: Track aggregate version for optimistic concurrency</li> <li>Keep focused: Aggregates should have a single responsibility</li> <li>Use records: Immutable records work well for aggregate state</li> </ol>"},{"location":"getting-started/concepts/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/concepts/#command-event-pattern","title":"Command-Event Pattern","text":"<pre><code>// Command (intent)\npublic record PlaceOrderCommand(string OrderId, string CustomerId, decimal Amount);\n\n// Event (fact)\npublic record OrderPlaced(string OrderId, string CustomerId, decimal Amount, DateTime PlacedAt);\n\n// Handler\npublic class OrderCommandHandler\n{\n    public async Task&lt;IEnumerable&lt;object&gt;&gt; Handle(PlaceOrderCommand command)\n    {\n        // Validation logic here\n        return new[] { new OrderPlaced(command.OrderId, command.CustomerId, command.Amount, DateTime.UtcNow) };\n    }\n}\n</code></pre>"},{"location":"getting-started/concepts/#saga-pattern","title":"Saga Pattern","text":"<p>For long-running processes that span multiple aggregates:</p> <pre><code>public record OrderSagaState(string OrderId, bool PaymentProcessed, bool InventoryReserved, bool EmailSent);\n\npublic static OrderSagaState Handle(OrderSagaState? state, OrderPlaced @event)\n    =&gt; new(@event.OrderId, false, false, false);\n</code></pre>"},{"location":"getting-started/concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Event Handlers in detail</li> <li>Understand Snapshot Management</li> <li>Explore Hash Integrity Verification</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>StreamDingo is available as a NuGet package and requires .NET 9.0 or later.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>.NET 9.0 SDK or later</li> <li>A .NET project targeting <code>net9.0</code> or later</li> </ul>"},{"location":"getting-started/installation/#package-installation","title":"Package Installation","text":""},{"location":"getting-started/installation/#using-net-cli","title":"Using .NET CLI","text":"<pre><code>dotnet add package StreamDingo\n</code></pre>"},{"location":"getting-started/installation/#using-package-manager-console","title":"Using Package Manager Console","text":"<pre><code>Install-Package StreamDingo\n</code></pre>"},{"location":"getting-started/installation/#using-packagereference","title":"Using PackageReference","text":"<p>Add the following to your <code>.csproj</code> file:</p> <pre><code>&lt;PackageReference Include=\"StreamDingo\" Version=\"0.1.0\" /&gt;\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>If you want to build StreamDingo from source:</p> <pre><code>git clone https://github.com/alexwiese/StreamDingo.git\ncd StreamDingo\ndotnet restore\ndotnet build\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Build your first event-sourced application</li> <li>Basic Concepts - Understand the core principles</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>Get up and running with StreamDingo in minutes!</p>"},{"location":"getting-started/quickstart/#installation","title":"Installation","text":"<p>Install StreamDingo via NuGet Package Manager:</p> <pre><code>dotnet add package StreamDingo\n</code></pre> <p>Or via Package Manager Console:</p> <pre><code>Install-Package StreamDingo\n</code></pre>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/quickstart/#1-define-your-events","title":"1. Define Your Events","text":"<pre><code>public record UserCreated(string UserId, string Name, string Email);\npublic record UserEmailUpdated(string UserId, string NewEmail);\n</code></pre>"},{"location":"getting-started/quickstart/#2-define-your-aggregate-state","title":"2. Define Your Aggregate State","text":"<pre><code>public record UserAggregate(string Id, string Name, string Email, int Version);\n</code></pre>"},{"location":"getting-started/quickstart/#3-create-event-handlers","title":"3. Create Event Handlers","text":"<pre><code>public class UserEventHandlers\n{\n    public static UserAggregate Handle(UserAggregate? state, UserCreated @event)\n        =&gt; new(@event.UserId, @event.Name, @event.Email, (state?.Version ?? 0) + 1);\n\n    public static UserAggregate Handle(UserAggregate state, UserEmailUpdated @event)\n        =&gt; state with { Email = @event.NewEmail, Version = state.Version + 1 };\n}\n</code></pre>"},{"location":"getting-started/quickstart/#4-set-up-event-store","title":"4. Set Up Event Store","text":"<pre><code>var eventStore = new InMemoryEventStore();\nvar streamManager = new EventStreamManager(eventStore);\n</code></pre>"},{"location":"getting-started/quickstart/#5-append-events-and-replay","title":"5. Append Events and Replay","text":"<pre><code>// Append events\nawait streamManager.AppendEventsAsync(\"user-123\", new object[]\n{\n    new UserCreated(\"user-123\", \"John Doe\", \"john@example.com\"),\n    new UserEmailUpdated(\"user-123\", \"john.doe@example.com\")\n});\n\n// Replay to get current state\nvar currentState = await streamManager.ReplayEventsAsync&lt;UserAggregate&gt;(\"user-123\");\nConsole.WriteLine($\"User: {currentState.Name}, Email: {currentState.Email}\");\n</code></pre>"},{"location":"getting-started/quickstart/#key-concepts","title":"Key Concepts","text":"<ul> <li>Events: Immutable facts about what happened in your system</li> <li>Event Handlers: Pure functions that apply events to aggregate state</li> <li>Snapshots: Cached aggregate state with hash-based integrity verification</li> <li>Event Replay: Rebuilding aggregate state by replaying events from snapshots</li> </ul>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Basic Concepts</li> <li>Explore Event Sourcing Patterns</li> <li>Check out Performance Guidelines</li> </ul>"},{"location":"guide/event-handlers/","title":"Event Handlers","text":"<p>Event handlers are the core building blocks of StreamDingo. They are pure functions that transform aggregate state by applying events.</p>"},{"location":"guide/event-handlers/#handler-fundamentals","title":"Handler Fundamentals","text":""},{"location":"guide/event-handlers/#pure-functions","title":"Pure Functions","text":"<p>Event handlers must be pure functions with no side effects:</p> <pre><code>// \u2705 Good: Pure function\npublic static UserAggregate Handle(UserAggregate? state, UserCreated @event)\n    =&gt; new UserAggregate(\n        Id: @event.UserId,\n        Name: @event.Name,\n        Email: @event.Email,\n        Version: (state?.Version ?? 0) + 1\n    );\n\n// \u274c Bad: Has side effects\npublic static UserAggregate Handle(UserAggregate? state, UserCreated @event)\n{\n    // Side effect: logging\n    Console.WriteLine($\"User created: {@event.UserId}\");\n\n    // Side effect: external service call\n    emailService.SendWelcomeEmail(@event.Email);\n\n    return new UserAggregate(/*...*/);\n}\n</code></pre>"},{"location":"guide/event-handlers/#handler-signature","title":"Handler Signature","text":"<p>All event handlers must follow this signature:</p> <pre><code>public static TAggregate Handle(TAggregate? previousState, TEvent @event)\n{\n    // Handler logic\n    return newState;\n}\n</code></pre> <p>Where: - <code>TAggregate</code>: The aggregate type being modified - <code>TEvent</code>: The specific event type being handled - <code>previousState</code>: Can be null for the first event in a stream - Return value: The new aggregate state</p>"},{"location":"guide/event-handlers/#registration-patterns","title":"Registration Patterns","text":""},{"location":"guide/event-handlers/#explicit-registration","title":"Explicit Registration","text":"<p>Register handlers explicitly with the DI container:</p> <pre><code>services.AddEventHandler&lt;UserAggregate, UserCreated&gt;(UserEventHandlers.Handle);\nservices.AddEventHandler&lt;UserAggregate, UserEmailChanged&gt;(UserEventHandlers.Handle);\nservices.AddEventHandler&lt;UserAggregate, UserDeactivated&gt;(UserEventHandlers.Handle);\n</code></pre>"},{"location":"guide/event-handlers/#convention-based-registration","title":"Convention-Based Registration","text":"<p>Use reflection to auto-register handlers:</p> <pre><code>services.AddEventHandlersFromAssembly(typeof(UserEventHandlers).Assembly);\n\n// Or with naming convention\nservices.AddEventHandlersWhere(type =&gt; \n    type.Name.EndsWith(\"EventHandlers\") &amp;&amp; \n    type.IsPublic &amp;&amp; \n    !type.IsAbstract);\n</code></pre>"},{"location":"guide/event-handlers/#attribute-based-registration","title":"Attribute-Based Registration","text":"<p>Use attributes to mark handlers for auto-registration:</p> <pre><code>public class UserEventHandlers\n{\n    [EventHandler]\n    public static UserAggregate Handle(UserAggregate? state, UserCreated @event)\n        =&gt; /* handler logic */;\n\n    [EventHandler]\n    public static UserAggregate Handle(UserAggregate state, UserEmailChanged @event)\n        =&gt; /* handler logic */;\n}\n</code></pre>"},{"location":"guide/event-handlers/#advanced-handler-patterns","title":"Advanced Handler Patterns","text":""},{"location":"guide/event-handlers/#null-state-handling","title":"Null State Handling","text":"<p>Always handle the case where previous state is null:</p> <pre><code>public static UserAggregate Handle(UserAggregate? state, UserCreated @event)\n{\n    // First event - state will be null\n    if (state == null)\n    {\n        return new UserAggregate(\n            Id: @event.UserId,\n            Name: @event.Name,\n            Email: @event.Email,\n            Version: 1\n        );\n    }\n\n    // Subsequent events - should not happen for UserCreated\n    throw new InvalidOperationException(\"User already exists\");\n}\n\npublic static UserAggregate Handle(UserAggregate state, UserEmailChanged @event)\n{\n    // State should never be null for update events\n    if (state == null)\n        throw new InvalidOperationException(\"Cannot update non-existent user\");\n\n    return state with \n    { \n        Email = @event.NewEmail,\n        Version = state.Version + 1\n    };\n}\n</code></pre>"},{"location":"guide/event-handlers/#validation-in-handlers","title":"Validation in Handlers","text":"<p>Include business rule validation:</p> <pre><code>public static AccountAggregate Handle(AccountAggregate state, MoneyWithdrawn @event)\n{\n    if (state == null)\n        throw new InvalidOperationException(\"Cannot withdraw from non-existent account\");\n\n    if (@event.Amount &lt;= 0)\n        throw new ArgumentException(\"Withdrawal amount must be positive\");\n\n    var newBalance = state.Balance - @event.Amount;\n    if (newBalance &lt; 0 &amp;&amp; !state.AllowOverdraft)\n        throw new InvalidOperationException(\"Insufficient funds\");\n\n    return state with \n    {\n        Balance = newBalance,\n        Version = state.Version + 1,\n        LastTransactionAt = @event.WithdrawnAt\n    };\n}\n</code></pre>"},{"location":"guide/event-handlers/#handling-multiple-event-types","title":"Handling Multiple Event Types","text":"<p>Use pattern matching for multiple event types:</p> <pre><code>public static UserAggregate Handle(UserAggregate? state, object @event)\n    =&gt; @event switch\n    {\n        UserCreated e =&gt; HandleUserCreated(state, e),\n        UserEmailChanged e =&gt; HandleUserEmailChanged(state, e),\n        UserDeactivated e =&gt; HandleUserDeactivated(state, e),\n        UserReactivated e =&gt; HandleUserReactivated(state, e),\n        _ =&gt; state ?? throw new InvalidOperationException(\"Unknown event type\")\n    };\n\nprivate static UserAggregate HandleUserCreated(UserAggregate? state, UserCreated @event)\n{\n    if (state != null)\n        throw new InvalidOperationException(\"User already exists\");\n\n    return new UserAggregate(/*...*/);\n}\n</code></pre>"},{"location":"guide/event-handlers/#handler-organization","title":"Handler Organization","text":""},{"location":"guide/event-handlers/#single-handler-class-per-aggregate","title":"Single Handler Class per Aggregate","text":"<p>Organize handlers by aggregate:</p> <pre><code>public static class UserEventHandlers\n{\n    public static UserAggregate Handle(UserAggregate? state, UserCreated @event) { /*...*/ }\n    public static UserAggregate Handle(UserAggregate state, UserEmailChanged @event) { /*...*/ }\n    public static UserAggregate Handle(UserAggregate state, UserDeactivated @event) { /*...*/ }\n}\n\npublic static class OrderEventHandlers  \n{\n    public static OrderAggregate Handle(OrderAggregate? state, OrderPlaced @event) { /*...*/ }\n    public static OrderAggregate Handle(OrderAggregate state, OrderShipped @event) { /*...*/ }\n    public static OrderAggregate Handle(OrderAggregate state, OrderCancelled @event) { /*...*/ }\n}\n</code></pre>"},{"location":"guide/event-handlers/#nested-handler-classes","title":"Nested Handler Classes","text":"<p>Group related handlers:</p> <pre><code>public static class UserEventHandlers\n{\n    public static class Creation\n    {\n        public static UserAggregate Handle(UserAggregate? state, UserCreated @event) { /*...*/ }\n    }\n\n    public static class ProfileManagement\n    {\n        public static UserAggregate Handle(UserAggregate state, UserNameChanged @event) { /*...*/ }\n        public static UserAggregate Handle(UserAggregate state, UserEmailChanged @event) { /*...*/ }\n    }\n\n    public static class AccountManagement\n    {\n        public static UserAggregate Handle(UserAggregate state, UserDeactivated @event) { /*...*/ }\n        public static UserAggregate Handle(UserAggregate state, UserReactivated @event) { /*...*/ }\n    }\n}\n</code></pre>"},{"location":"guide/event-handlers/#error-handling","title":"Error Handling","text":""},{"location":"guide/event-handlers/#handler-exceptions","title":"Handler Exceptions","text":"<p>When handlers throw exceptions, replay will stop at that point:</p> <pre><code>public static UserAggregate Handle(UserAggregate state, UserEmailChanged @event)\n{\n    if (string.IsNullOrWhiteSpace(@event.NewEmail))\n        throw new ArgumentException(\"Email cannot be empty\", nameof(@event.NewEmail));\n\n    if (!IsValidEmail(@event.NewEmail))\n        throw new ArgumentException(\"Invalid email format\", nameof(@event.NewEmail));\n\n    return state with { Email = @event.NewEmail, Version = state.Version + 1 };\n}\n</code></pre>"},{"location":"guide/event-handlers/#graceful-degradation","title":"Graceful Degradation","text":"<p>For non-critical validation, consider logging instead of throwing:</p> <pre><code>public static UserAggregate Handle(UserAggregate state, UserProfileUpdated @event, ILogger logger)\n{\n    var newState = state with \n    {\n        Name = @event.NewName,\n        Version = state.Version + 1\n    };\n\n    // Validate but don't fail\n    if (string.IsNullOrWhiteSpace(@event.NewName))\n    {\n        logger.LogWarning(\"User {UserId} updated with empty name\", state.Id);\n    }\n\n    return newState;\n}\n</code></pre>"},{"location":"guide/event-handlers/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guide/event-handlers/#avoid-heavy-computations","title":"Avoid Heavy Computations","text":"<p>Keep handlers lightweight:</p> <pre><code>// \u274c Avoid: Heavy computation in handler\npublic static UserAggregate Handle(UserAggregate state, UserScoreCalculated @event)\n{\n    // This should be done before creating the event\n    var complexScore = CalculateComplexUserScore(@event.UserData);\n\n    return state with { Score = complexScore };\n}\n\n// \u2705 Better: Pre-computed values in events\npublic static UserAggregate Handle(UserAggregate state, UserScoreCalculated @event)\n{\n    return state with { Score = @event.CalculatedScore };\n}\n</code></pre>"},{"location":"guide/event-handlers/#use-records-for-immutability","title":"Use Records for Immutability","text":"<p>Records provide efficient immutable updates:</p> <pre><code>// \u2705 Efficient with records\nreturn state with \n{ \n    Email = @event.NewEmail,\n    Version = state.Version + 1\n};\n\n// \u274c Less efficient object creation\nreturn new UserAggregate(\n    state.Id,\n    state.Name,\n    @event.NewEmail, // Only this changed\n    state.Status,\n    state.CreatedAt,\n    state.Version + 1\n);\n</code></pre>"},{"location":"guide/event-handlers/#testing-event-handlers","title":"Testing Event Handlers","text":""},{"location":"guide/event-handlers/#unit-testing","title":"Unit Testing","text":"<p>Test handlers in isolation:</p> <pre><code>[Test]\npublic void UserCreated_Should_Create_New_User()\n{\n    // Arrange\n    var @event = new UserCreated(\"user-1\", \"John Doe\", \"john@example.com\");\n\n    // Act\n    var result = UserEventHandlers.Handle(null, @event);\n\n    // Assert\n    Assert.That(result.Id, Is.EqualTo(\"user-1\"));\n    Assert.That(result.Name, Is.EqualTo(\"John Doe\"));\n    Assert.That(result.Email, Is.EqualTo(\"john@example.com\"));\n    Assert.That(result.Version, Is.EqualTo(1));\n}\n\n[Test]\npublic void UserEmailChanged_Should_Update_Email()\n{\n    // Arrange\n    var state = new UserAggregate(\"user-1\", \"John\", \"old@example.com\", UserStatus.Active, 1);\n    var @event = new UserEmailChanged(\"user-1\", \"new@example.com\");\n\n    // Act\n    var result = UserEventHandlers.Handle(state, @event);\n\n    // Assert\n    Assert.That(result.Email, Is.EqualTo(\"new@example.com\"));\n    Assert.That(result.Version, Is.EqualTo(2));\n    Assert.That(result.Name, Is.EqualTo(\"John\")); // Unchanged\n}\n</code></pre>"},{"location":"guide/event-handlers/#property-based-testing","title":"Property-Based Testing","text":"<p>Use property-based testing for handler invariants:</p> <pre><code>[Property]\npublic Property Handler_Should_Always_Increment_Version(UserAggregate state, UserEmailChanged @event)\n{\n    var result = UserEventHandlers.Handle(state, @event);\n    return (result.Version == state.Version + 1).ToProperty();\n}\n\n[Property]\npublic Property Handler_Should_Preserve_Id(UserAggregate state, UserEmailChanged @event)\n{\n    var result = UserEventHandlers.Handle(state, @event);\n    return (result.Id == state.Id).ToProperty();\n}\n</code></pre>"},{"location":"guide/event-handlers/#handler-versioning","title":"Handler Versioning","text":""},{"location":"guide/event-handlers/#handling-schema-evolution","title":"Handling Schema Evolution","text":"<p>When event schemas change, use versioned handlers:</p> <pre><code>public static UserAggregate Handle(UserAggregate? state, UserCreatedV1 @event)\n{\n    // Handle old version\n    return new UserAggregate(\n        Id: @event.UserId,\n        Name: @event.Name,\n        Email: @event.Email,\n        PhoneNumber: null, // New field in V2\n        Version: (state?.Version ?? 0) + 1\n    );\n}\n\npublic static UserAggregate Handle(UserAggregate? state, UserCreatedV2 @event)  \n{\n    // Handle new version\n    return new UserAggregate(\n        Id: @event.UserId,\n        Name: @event.Name,\n        Email: @event.Email,\n        PhoneNumber: @event.PhoneNumber, // New in V2\n        Version: (state?.Version ?? 0) + 1\n    );\n}\n</code></pre>"},{"location":"guide/event-handlers/#migration-handlers","title":"Migration Handlers","text":"<p>Create handlers to migrate between versions:</p> <pre><code>public static UserCreatedV2 Migrate(UserCreatedV1 oldEvent)\n{\n    return new UserCreatedV2(\n        UserId: oldEvent.UserId,\n        Name: oldEvent.Name,\n        Email: oldEvent.Email,\n        PhoneNumber: null // Default for missing field\n    );\n}\n</code></pre>"},{"location":"guide/event-handlers/#hash-based-change-detection","title":"Hash-Based Change Detection","text":"<p>StreamDingo uses hash-based change detection to determine when handlers have changed:</p>"},{"location":"guide/event-handlers/#what-triggers-replay","title":"What Triggers Replay","text":"<ul> <li>Handler method body changes</li> <li>Handler dependencies change (referenced methods, constants)</li> <li>Event type schema changes</li> </ul>"},{"location":"guide/event-handlers/#optimizing-for-hash-stability","title":"Optimizing for Hash Stability","text":"<p>Keep handlers stable to avoid unnecessary replays:</p> <pre><code>// \u2705 Stable: Logic unlikely to change\npublic static UserAggregate Handle(UserAggregate? state, UserCreated @event)\n    =&gt; new UserAggregate(@event.UserId, @event.Name, @event.Email, 1);\n\n// \u274c Unstable: Formatting/comments cause hash changes\npublic static UserAggregate Handle(UserAggregate? state, UserCreated @event)\n{\n    // TODO: Add validation\n    return new UserAggregate(\n        id: @event.UserId,      // Changed parameter name\n        name: @event.Name,\n        email: @event.Email,\n        version: 1\n    );\n}\n</code></pre>"},{"location":"guide/event-handlers/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Snapshots and their relationship to handlers</li> <li>Understand Hash Integrity verification</li> <li>Explore Event Replay strategies</li> <li>See Storage Providers for persistence options</li> </ul>"},{"location":"guide/event-replay/","title":"Event Replay","text":"<p>Event replay is the process of reconstructing aggregate state by reapplying stored events. StreamDingo provides intelligent replay strategies optimized for performance and integrity.</p>"},{"location":"guide/event-replay/#replay-triggers","title":"Replay Triggers","text":""},{"location":"guide/event-replay/#handler-code-changes","title":"Handler Code Changes","text":"<p>When event handler code changes, affected streams need replay:</p> <pre><code>// Handler change detected - replay required\nvar currentHash = hashProvider.HashEventHandlers&lt;UserAggregate&gt;();\nif (currentHash != snapshot.Metadata.AggregateHash)\n{\n    await TriggerReplayAsync&lt;UserAggregate&gt;(streamId);\n}\n</code></pre>"},{"location":"guide/event-replay/#data-integrity-issues","title":"Data Integrity Issues","text":"<p>Corrupted snapshots trigger replay from last valid state:</p> <pre><code>var snapshotValid = await VerifySnapshotIntegrityAsync(streamId);\nif (!snapshotValid)\n{\n    await ReplayFromLastValidSnapshotAsync(streamId);\n}\n</code></pre>"},{"location":"guide/event-replay/#replay-strategies","title":"Replay Strategies","text":""},{"location":"guide/event-replay/#full-replay","title":"Full Replay","text":"<p>Replay all events from the beginning:</p> <pre><code>public async Task&lt;TAggregate?&gt; FullReplayAsync&lt;TAggregate&gt;(string streamId)\n{\n    var events = await eventStore.GetAllEventsAsync(streamId);\n    return events.Aggregate(default(TAggregate), ApplyEventToState);\n}\n</code></pre>"},{"location":"guide/event-replay/#snapshot-based-replay","title":"Snapshot-Based Replay","text":"<p>Replay from the most recent valid snapshot:</p> <pre><code>public async Task&lt;TAggregate?&gt; SnapshotBasedReplayAsync&lt;TAggregate&gt;(string streamId)\n{\n    var snapshot = await GetLatestValidSnapshotAsync&lt;TAggregate&gt;(streamId);\n    var events = await eventStore.GetEventsFromVersionAsync(streamId, snapshot.Version + 1);\n\n    return events.Aggregate(snapshot.State, ApplyEventToState);\n}\n</code></pre>"},{"location":"guide/event-replay/#performance-optimization","title":"Performance Optimization","text":""},{"location":"guide/event-replay/#batch-processing","title":"Batch Processing","text":"<p>Process events in batches for better performance:</p> <pre><code>public async Task&lt;TAggregate?&gt; BatchReplayAsync&lt;TAggregate&gt;(string streamId, int batchSize = 1000)\n{\n    var state = default(TAggregate);\n    var version = 0L;\n\n    while (true)\n    {\n        var events = await eventStore.GetEventBatchAsync(streamId, version, batchSize);\n        if (!events.Any()) break;\n\n        foreach (var @event in events)\n        {\n            state = ApplyEventToState(state, @event);\n        }\n\n        version = events.Last().Version + 1;\n    }\n\n    return state;\n}\n</code></pre>"},{"location":"guide/event-replay/#parallel-replay","title":"Parallel Replay","text":"<p>For multiple streams, use parallel processing:</p> <pre><code>public async Task&lt;Dictionary&lt;string, TAggregate&gt;&gt; ReplayMultipleStreamsAsync&lt;TAggregate&gt;(\n    IEnumerable&lt;string&gt; streamIds)\n{\n    var tasks = streamIds.Select(async streamId =&gt;\n    {\n        var state = await ReplayEventsAsync&lt;TAggregate&gt;(streamId);\n        return new KeyValuePair&lt;string, TAggregate&gt;(streamId, state);\n    });\n\n    var results = await Task.WhenAll(tasks);\n    return results.ToDictionary(r =&gt; r.Key, r =&gt; r.Value);\n}\n</code></pre>"},{"location":"guide/event-replay/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Storage Providers</li> <li>Explore Performance optimization</li> </ul>"},{"location":"guide/event-sourcing/","title":"Event Sourcing with StreamDingo","text":"<p>Event sourcing is a powerful architectural pattern that stores data as a sequence of events rather than the current state. StreamDingo makes event sourcing accessible and efficient in .NET applications.</p>"},{"location":"guide/event-sourcing/#core-principles","title":"Core Principles","text":""},{"location":"guide/event-sourcing/#immutable-event-log","title":"Immutable Event Log","text":"<p>Instead of updating records in place, event sourcing appends new events to an immutable log:</p> <pre><code>// Traditional approach (mutating state)\nuser.Email = \"newemail@example.com\";\nuser.UpdatedAt = DateTime.UtcNow;\ndatabase.Update(user);\n\n// Event sourcing approach (append events)\nvar @event = new UserEmailChanged(user.Id, \"newemail@example.com\", DateTime.UtcNow);\nawait eventStore.AppendEventAsync(user.Id, @event);\n</code></pre>"},{"location":"guide/event-sourcing/#state-reconstruction","title":"State Reconstruction","text":"<p>Current state is reconstructed by replaying events from the beginning:</p> <pre><code>var events = await eventStore.GetEventsAsync(userId);\nvar currentUser = events.Aggregate((UserAggregate?)null, (state, @event) =&gt;\n    @event switch\n    {\n        UserRegistered e =&gt; UserEventHandlers.Handle(state, e),\n        UserEmailChanged e =&gt; UserEventHandlers.Handle(state, e),\n        UserDeactivated e =&gt; UserEventHandlers.Handle(state, e),\n        _ =&gt; state\n    });\n</code></pre>"},{"location":"guide/event-sourcing/#benefits-of-event-sourcing","title":"Benefits of Event Sourcing","text":""},{"location":"guide/event-sourcing/#complete-audit-trail","title":"Complete Audit Trail","text":"<p>Every change is preserved with full context:</p> <pre><code>public record UserEmailChanged(\n    string UserId, \n    string NewEmail, \n    string PreviousEmail, \n    DateTime ChangedAt, \n    string ChangedBy,\n    string Reason\n);\n</code></pre>"},{"location":"guide/event-sourcing/#time-travel","title":"Time Travel","text":"<p>Query your system's state at any point in time:</p> <pre><code>// Get user state as of a specific date\nvar userStateAt = await streamManager.ReplayEventsAsync&lt;UserAggregate&gt;(\n    userId, \n    upToTimestamp: DateTime.Parse(\"2024-01-15\"));\n</code></pre>"},{"location":"guide/event-sourcing/#event-driven-integration","title":"Event-Driven Integration","text":"<p>Events can trigger downstream processes:</p> <pre><code>public class UserEmailChangedHandler : IEventHandler&lt;UserEmailChanged&gt;\n{\n    public async Task HandleAsync(UserEmailChanged @event)\n    {\n        // Update search index\n        await searchService.UpdateUserEmailAsync(@event.UserId, @event.NewEmail);\n\n        // Send notification\n        await emailService.SendEmailChangeConfirmationAsync(@event.NewEmail);\n\n        // Update analytics\n        await analyticsService.TrackUserEmailChangeAsync(@event.UserId);\n    }\n}\n</code></pre>"},{"location":"guide/event-sourcing/#streamdingos-approach","title":"StreamDingo's Approach","text":""},{"location":"guide/event-sourcing/#handler-based-architecture","title":"Handler-Based Architecture","text":"<p>StreamDingo uses pure functions to handle events:</p> <pre><code>public class UserEventHandlers\n{\n    public static UserAggregate Handle(UserAggregate? state, UserRegistered @event)\n        =&gt; new UserAggregate(\n            Id: @event.UserId,\n            Email: @event.Email,\n            Name: @event.Name,\n            Status: UserStatus.Active,\n            Version: (state?.Version ?? 0) + 1\n        );\n\n    public static UserAggregate Handle(UserAggregate state, UserEmailChanged @event)\n        =&gt; state with { \n            Email = @event.NewEmail, \n            Version = state.Version + 1 \n        };\n}\n</code></pre>"},{"location":"guide/event-sourcing/#intelligent-replay","title":"Intelligent Replay","text":"<p>StreamDingo optimizes replay using snapshots and hash-based change detection:</p> <pre><code>graph LR\n    A[Event 1] --&gt; B[Event 2]\n    B --&gt; C[Event 3]\n    C --&gt; D[Snapshot]\n    D --&gt; E[Event 4]\n    E --&gt; F[Event 5]\n    F --&gt; G[Current State]\n\n    H[Handler Change] --&gt; I[Replay from Snapshot]\n    I --&gt; G</code></pre>"},{"location":"guide/event-sourcing/#implementation-patterns","title":"Implementation Patterns","text":""},{"location":"guide/event-sourcing/#basic-event-store-setup","title":"Basic Event Store Setup","text":"<pre><code>// Configure event store\nservices.AddSingleton&lt;IEventStore, InMemoryEventStore&gt;();\nservices.AddSingleton&lt;ISnapshotStore, InMemorySnapshotStore&gt;();\nservices.AddSingleton&lt;IHashProvider, HashStampProvider&gt;();\nservices.AddSingleton&lt;IEventStreamManager, EventStreamManager&gt;();\n\n// Register event handlers\nservices.AddEventHandler&lt;UserAggregate, UserRegistered&gt;(UserEventHandlers.Handle);\nservices.AddEventHandler&lt;UserAggregate, UserEmailChanged&gt;(UserEventHandlers.Handle);\n</code></pre>"},{"location":"guide/event-sourcing/#command-handler-pattern","title":"Command Handler Pattern","text":"<pre><code>public class UserCommandHandler\n{\n    private readonly IEventStreamManager _streamManager;\n\n    public UserCommandHandler(IEventStreamManager streamManager)\n    {\n        _streamManager = streamManager;\n    }\n\n    public async Task&lt;UserAggregate&gt; RegisterUserAsync(RegisterUserCommand command)\n    {\n        var @event = new UserRegistered(\n            UserId: Guid.NewGuid().ToString(),\n            Email: command.Email,\n            Name: command.Name,\n            RegisteredAt: DateTime.UtcNow\n        );\n\n        await _streamManager.AppendEventAsync(@event.UserId, @event);\n        return await _streamManager.ReplayEventsAsync&lt;UserAggregate&gt;(@event.UserId);\n    }\n}\n</code></pre>"},{"location":"guide/event-sourcing/#projection-pattern","title":"Projection Pattern","text":"<pre><code>public class UserProjectionHandler\n{\n    public async Task HandleAsync(UserRegistered @event)\n    {\n        var projection = new UserProjection\n        {\n            Id = @event.UserId,\n            Email = @event.Email,\n            Name = @event.Name,\n            CreatedAt = @event.RegisteredAt\n        };\n\n        await projectionStore.SaveAsync(projection);\n    }\n\n    public async Task HandleAsync(UserEmailChanged @event)\n    {\n        var projection = await projectionStore.GetAsync(@event.UserId);\n        projection.Email = @event.NewEmail;\n        projection.UpdatedAt = @event.ChangedAt;\n\n        await projectionStore.SaveAsync(projection);\n    }\n}\n</code></pre>"},{"location":"guide/event-sourcing/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guide/event-sourcing/#snapshot-strategy","title":"Snapshot Strategy","text":"<p>Configure automatic snapshots for long-lived aggregates:</p> <pre><code>services.Configure&lt;SnapshotOptions&gt;(options =&gt;\n{\n    options.SnapshotEveryNEvents = 100;\n    options.MaxSnapshotsPerStream = 10;\n    options.EnableAutomaticSnapshots = true;\n});\n</code></pre>"},{"location":"guide/event-sourcing/#batch-operations","title":"Batch Operations","text":"<p>Use batch operations for bulk event processing:</p> <pre><code>var events = GenerateBulkEvents();\nawait eventStore.AppendEventsBatchAsync(streamId, events);\n</code></pre>"},{"location":"guide/event-sourcing/#read-models","title":"Read Models","text":"<p>Use projections for optimized read operations:</p> <pre><code>// Instead of replaying events every time\nvar user = await streamManager.ReplayEventsAsync&lt;UserAggregate&gt;(userId);\n\n// Use pre-built projections for queries\nvar userSummary = await projectionStore.GetUserSummaryAsync(userId);\n</code></pre>"},{"location":"guide/event-sourcing/#testing-event-sourced-systems","title":"Testing Event-Sourced Systems","text":""},{"location":"guide/event-sourcing/#unit-testing-event-handlers","title":"Unit Testing Event Handlers","text":"<pre><code>[Test]\npublic void Should_Update_User_Email()\n{\n    // Given\n    var initialState = new UserAggregate(\"user-1\", \"old@example.com\", \"John\", UserStatus.Active, 1);\n    var @event = new UserEmailChanged(\"user-1\", \"new@example.com\");\n\n    // When\n    var newState = UserEventHandlers.Handle(initialState, @event);\n\n    // Then\n    Assert.That(newState.Email, Is.EqualTo(\"new@example.com\"));\n    Assert.That(newState.Version, Is.EqualTo(2));\n}\n</code></pre>"},{"location":"guide/event-sourcing/#integration-testing","title":"Integration Testing","text":"<pre><code>[Test]\npublic async Task Should_Store_And_Replay_Events()\n{\n    // Given\n    var streamId = \"test-stream\";\n    var events = new object[]\n    {\n        new UserRegistered(\"user-1\", \"test@example.com\", \"Test User\"),\n        new UserEmailChanged(\"user-1\", \"updated@example.com\")\n    };\n\n    // When\n    await streamManager.AppendEventsAsync(streamId, events);\n    var state = await streamManager.ReplayEventsAsync&lt;UserAggregate&gt;(streamId);\n\n    // Then\n    Assert.That(state.Email, Is.EqualTo(\"updated@example.com\"));\n    Assert.That(state.Version, Is.EqualTo(2));\n}\n</code></pre>"},{"location":"guide/event-sourcing/#common-anti-patterns-to-avoid","title":"Common Anti-Patterns to Avoid","text":""},{"location":"guide/event-sourcing/#overly-granular-events","title":"Overly Granular Events","text":"<pre><code>// Avoid: Too many tiny events\nUserFirstNameChanged, UserLastNameChanged, UserMiddleNameChanged\n\n// Better: Logical grouping\nUserNameChanged(firstName, lastName, middleName)\n</code></pre>"},{"location":"guide/event-sourcing/#events-with-side-effects","title":"Events with Side Effects","text":"<pre><code>// Avoid: Events that cause side effects\npublic record EmailSent(string to, string subject); // This is an action, not an event\n\n// Better: Events that record what happened\npublic record UserNotificationSent(string userId, string notificationType, DateTime sentAt);\n</code></pre>"},{"location":"guide/event-sourcing/#temporal-coupling","title":"Temporal Coupling","text":"<pre><code>// Avoid: Events that depend on execution order across aggregates\npublic record OrderPlaced(string orderId, string productId);\npublic record InventoryReduced(string productId, int quantity); // Separate aggregate\n\n// Better: Include all necessary context\npublic record OrderPlaced(string orderId, string productId, int quantity, bool inventoryReserved);\n</code></pre>"},{"location":"guide/event-sourcing/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Event Handlers in detail</li> <li>Understand Snapshot Management</li> <li>Explore Hash Integrity verification</li> <li>See Event Replay strategies</li> </ul>"},{"location":"guide/hash-integrity/","title":"Hash Integrity","text":"<p>StreamDingo uses hash-based integrity verification to ensure the reliability of your event-sourced system by detecting changes in event handler code and verifying data integrity.</p>"},{"location":"guide/hash-integrity/#overview","title":"Overview","text":"<p>Hash integrity verification serves two main purposes: 1. Code Change Detection: Detects when event handler code changes, triggering necessary replays 2. Data Integrity: Verifies that stored snapshots and events haven't been corrupted or tampered with</p>"},{"location":"guide/hash-integrity/#hash-provider-integration","title":"Hash Provider Integration","text":"<p>StreamDingo integrates with the <code>alexwiese/hashstamp</code> library for robust hash generation:</p> <pre><code>services.AddSingleton&lt;IHashProvider, HashStampProvider&gt;();\n</code></pre>"},{"location":"guide/hash-integrity/#hash-types","title":"Hash Types","text":""},{"location":"guide/hash-integrity/#handler-code-hashes","title":"Handler Code Hashes","text":"<p>Generated from event handler method bodies and their dependencies:</p> <pre><code>public class HashStampProvider : IHashProvider\n{\n    public string HashEventHandlers&lt;TAggregate&gt;()\n    {\n        var handlerMethods = GetEventHandlerMethods&lt;TAggregate&gt;();\n        var combinedHash = new StringBuilder();\n\n        foreach (var method in handlerMethods)\n        {\n            var methodHash = HashStamp.GenerateHash(method);\n            combinedHash.Append(methodHash);\n        }\n\n        return HashStamp.GenerateHash(combinedHash.ToString());\n    }\n}\n</code></pre>"},{"location":"guide/hash-integrity/#data-hashes","title":"Data Hashes","text":"<p>Generated from serialized object data:</p> <pre><code>public string HashObject&lt;T&gt;(T obj)\n{\n    var json = JsonSerializer.Serialize(obj, _jsonOptions);\n    return HashStamp.GenerateHash(json);\n}\n</code></pre>"},{"location":"guide/hash-integrity/#change-detection-scenarios","title":"Change Detection Scenarios","text":""},{"location":"guide/hash-integrity/#handler-code-changes","title":"Handler Code Changes","text":"<p>When event handler code changes, affected events must be replayed:</p> <pre><code>// Original handler\npublic static UserAggregate Handle(UserAggregate? state, UserCreated @event)\n    =&gt; new UserAggregate(@event.UserId, @event.Name, @event.Email, 1);\n\n// Modified handler (business logic change)\npublic static UserAggregate Handle(UserAggregate? state, UserCreated @event)\n    =&gt; new UserAggregate(@event.UserId, @event.Name?.ToUpper(), @event.Email, 1); // Name now uppercase\n</code></pre>"},{"location":"guide/hash-integrity/#what-triggers-hash-changes","title":"What Triggers Hash Changes","text":""},{"location":"guide/hash-integrity/#code-changes-that-matter","title":"Code Changes That Matter","text":"<pre><code>// \u2705 These changes trigger replay (as they should)\npublic static UserAggregate Handle(UserAggregate? state, UserCreated @event)\n{\n    // Business logic change\n    var normalizedEmail = @event.Email.ToLowerInvariant(); // NEW\n\n    // Validation change\n    if (string.IsNullOrEmpty(@event.Name)) // NEW\n        throw new ArgumentException(\"Name cannot be empty\");\n\n    return new UserAggregate(@event.UserId, @event.Name, normalizedEmail, 1);\n}\n</code></pre>"},{"location":"guide/hash-integrity/#code-changes-that-dont-matter","title":"Code Changes That Don't Matter","text":"<pre><code>// \u274c These changes also trigger replay (but shouldn't affect behavior)\npublic static UserAggregate Handle(UserAggregate? state, UserCreated @event)\n{\n    // Comment changes trigger hash changes\n    // This is a new comment that changes the hash\n\n    // Variable name changes trigger hash changes  \n    var userId = @event.UserId; // was: var id = @event.UserId;\n\n    // Whitespace changes trigger hash changes\n    return new UserAggregate(userId, @event.Name, \n                           @event.Email, 1); // Different formatting\n}\n</code></pre>"},{"location":"guide/hash-integrity/#replay-strategies","title":"Replay Strategies","text":""},{"location":"guide/hash-integrity/#intelligent-replay","title":"Intelligent Replay","text":"<p>StreamDingo determines optimal replay strategies based on hash changes:</p> <pre><code>flowchart TD\n    A[Event Handler Change Detected] --&gt; B{Snapshot Available?}\n    B --&gt;|Yes| C{Snapshot Hash Valid?}\n    B --&gt;|No| D[Full Replay from Beginning]\n    C --&gt;|Yes| E[Replay from Snapshot]\n    C --&gt;|No| F[Find Next Valid Snapshot]\n    F --&gt; G{Valid Snapshot Found?}\n    G --&gt;|Yes| E\n    G --&gt;|No| D\n    E --&gt; H[Current State]\n    D --&gt; H</code></pre>"},{"location":"guide/hash-integrity/#implementation","title":"Implementation","text":"<pre><code>public async Task&lt;TAggregate?&gt; ReplayWithHashVerificationAsync&lt;TAggregate&gt;(string streamId)\n{\n    var currentHandlerHash = _hashProvider.HashEventHandlers&lt;TAggregate&gt;();\n\n    // Check if we have a valid snapshot\n    var snapshots = await _snapshotStore.GetSnapshotsAsync&lt;TAggregate&gt;(streamId);\n\n    foreach (var snapshot in snapshots.OrderByDescending(s =&gt; s.Metadata.EventVersion))\n    {\n        // Verify snapshot data integrity\n        var snapshotDataHash = _hashProvider.HashObject(snapshot.State);\n        if (snapshotDataHash != snapshot.Metadata.SnapshotHash)\n        {\n            _logger.LogWarning(\"Snapshot data corruption detected at version {Version}\", \n                snapshot.Metadata.EventVersion);\n            continue; // Try older snapshot\n        }\n\n        // Check if handler code has changed since snapshot\n        if (currentHandlerHash == snapshot.Metadata.AggregateHash)\n        {\n            // Handler hasn't changed, can use this snapshot\n            return await ReplayFromSnapshotAsync(snapshot, streamId);\n        }\n\n        _logger.LogInformation(\"Handler code changed since snapshot at version {Version}, continuing search\", \n            snapshot.Metadata.EventVersion);\n    }\n\n    // No valid snapshot found, replay from beginning\n    _logger.LogInformation(\"No valid snapshot found for {StreamId}, replaying from beginning\", streamId);\n    return await ReplayFromBeginningAsync&lt;TAggregate&gt;(streamId);\n}\n</code></pre>"},{"location":"guide/hash-integrity/#data-integrity-verification","title":"Data Integrity Verification","text":""},{"location":"guide/hash-integrity/#snapshot-verification","title":"Snapshot Verification","text":"<p>Verify snapshot integrity when loading:</p> <pre><code>public async Task&lt;bool&gt; VerifySnapshotIntegrityAsync&lt;TAggregate&gt;(string streamId)\n{\n    var snapshot = await _snapshotStore.GetSnapshotAsync&lt;TAggregate&gt;(streamId);\n    if (snapshot == null) return true; // No snapshot to verify\n\n    var currentHash = _hashProvider.HashObject(snapshot.State);\n    var storedHash = snapshot.Metadata.SnapshotHash;\n\n    if (currentHash != storedHash)\n    {\n        _logger.LogError(\"Snapshot integrity verification failed for {StreamId}. \" +\n                        \"Current hash: {CurrentHash}, Stored hash: {StoredHash}\",\n                        streamId, currentHash, storedHash);\n        return false;\n    }\n\n    return true;\n}\n</code></pre>"},{"location":"guide/hash-integrity/#event-integrity-future-feature","title":"Event Integrity (Future Feature)","text":"<p>Individual event integrity verification:</p> <pre><code>public class EventWithHash\n{\n    public object Event { get; set; }\n    public string EventHash { get; set; }\n    public long Version { get; set; }\n    public DateTime Timestamp { get; set; }\n}\n\npublic async Task&lt;bool&gt; VerifyEventIntegrityAsync(string streamId, long version)\n{\n    var eventData = await _eventStore.GetEventAsync(streamId, version);\n    if (eventData == null) return false;\n\n    var currentHash = _hashProvider.HashObject(eventData.Event);\n    return currentHash == eventData.EventHash;\n}\n</code></pre>"},{"location":"guide/hash-integrity/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guide/hash-integrity/#hash-caching","title":"Hash Caching","text":"<p>Cache handler hashes to avoid repeated computation:</p> <pre><code>public class CachedHashProvider : IHashProvider\n{\n    private readonly ConcurrentDictionary&lt;Type, string&gt; _handlerHashCache = new();\n    private readonly IHashProvider _innerProvider;\n\n    public string HashEventHandlers&lt;TAggregate&gt;()\n    {\n        return _handlerHashCache.GetOrAdd(typeof(TAggregate), \n            _ =&gt; _innerProvider.HashEventHandlers&lt;TAggregate&gt;());\n    }\n\n    public void InvalidateCache&lt;TAggregate&gt;()\n    {\n        _handlerHashCache.TryRemove(typeof(TAggregate), out _);\n    }\n}\n</code></pre>"},{"location":"guide/hash-integrity/#selective-hashing","title":"Selective Hashing","text":"<p>Only hash relevant parts of handlers:</p> <pre><code>public string HashEventHandlers&lt;TAggregate&gt;()\n{\n    var relevantMethods = typeof(TAggregate).Assembly\n        .GetTypes()\n        .SelectMany(t =&gt; t.GetMethods())\n        .Where(m =&gt; IsEventHandlerMethod&lt;TAggregate&gt;(m))\n        .Where(m =&gt; !HasIgnoreHashAttribute(m)); // Allow excluding certain methods\n\n    return HashMethods(relevantMethods);\n}\n</code></pre>"},{"location":"guide/hash-integrity/#configuration-options","title":"Configuration Options","text":""},{"location":"guide/hash-integrity/#hash-provider-options","title":"Hash Provider Options","text":"<pre><code>services.Configure&lt;HashProviderOptions&gt;(options =&gt;\n{\n    options.IncludeMethodComments = false;    // Ignore comment changes\n    options.IgnoreWhitespaceChanges = true;   // Ignore formatting changes\n    options.HashPrivateMethods = false;       // Only hash public handler methods\n    options.CacheHashResults = true;          // Enable hash caching\n});\n</code></pre>"},{"location":"guide/hash-integrity/#integrity-check-frequency","title":"Integrity Check Frequency","text":"<pre><code>services.Configure&lt;IntegrityCheckOptions&gt;(options =&gt;\n{\n    options.VerifySnapshotIntegrity = true;           // Always verify snapshots\n    options.VerifyEventIntegrity = false;             // Skip individual event verification (expensive)\n    options.PeriodicIntegrityCheck = TimeSpan.FromHours(24); // Full integrity check daily\n});\n</code></pre>"},{"location":"guide/hash-integrity/#monitoring-and-alerting","title":"Monitoring and Alerting","text":""},{"location":"guide/hash-integrity/#hash-change-monitoring","title":"Hash Change Monitoring","text":"<p>Track when handler changes trigger replays:</p> <pre><code>public class HashChangeTracker\n{\n    public async Task OnHandlerHashChanged&lt;TAggregate&gt;(string oldHash, string newHash)\n    {\n        var changeInfo = new HandlerHashChangeEvent\n        {\n            AggregateType = typeof(TAggregate).Name,\n            OldHash = oldHash,\n            NewHash = newHash,\n            Timestamp = DateTime.UtcNow,\n            RequiredReplays = await GetAffectedStreamsAsync&lt;TAggregate&gt;()\n        };\n\n        await _eventBus.PublishAsync(changeInfo);\n\n        // Alert if many streams need replay\n        if (changeInfo.RequiredReplays.Count &gt; 100)\n        {\n            await _alertingService.SendAlertAsync(\n                \"High impact handler change detected\", \n                $\"{changeInfo.RequiredReplays.Count} streams require replay\");\n        }\n    }\n}\n</code></pre>"},{"location":"guide/hash-integrity/#integrity-violation-alerts","title":"Integrity Violation Alerts","text":"<pre><code>public class IntegrityViolationHandler\n{\n    public async Task OnSnapshotCorruptionDetected(string streamId, string snapshotHash)\n    {\n        await _alertingService.SendCriticalAlertAsync(\n            \"Snapshot corruption detected\",\n            $\"Stream {streamId} has corrupted snapshot with hash {snapshotHash}\");\n\n        // Automatically attempt recovery\n        await _recoveryService.RecoverFromCorruption(streamId);\n    }\n}\n</code></pre>"},{"location":"guide/hash-integrity/#testing-hash-integrity","title":"Testing Hash Integrity","text":""},{"location":"guide/hash-integrity/#unit-tests","title":"Unit Tests","text":"<pre><code>[Test]\npublic void Should_Generate_Same_Hash_For_Identical_Handlers()\n{\n    var hash1 = hashProvider.HashEventHandlers&lt;UserAggregate&gt;();\n    var hash2 = hashProvider.HashEventHandlers&lt;UserAggregate&gt;();\n\n    Assert.That(hash1, Is.EqualTo(hash2));\n}\n\n[Test]\npublic void Should_Generate_Different_Hash_When_Handler_Changes()\n{\n    var originalHash = hashProvider.HashEventHandlers&lt;UserAggregate&gt;();\n\n    // Simulate handler change by modifying the type\n    ModifyHandlerCode&lt;UserAggregate&gt;();\n\n    var newHash = hashProvider.HashEventHandlers&lt;UserAggregate&gt;();\n\n    Assert.That(newHash, Is.Not.EqualTo(originalHash));\n}\n</code></pre>"},{"location":"guide/hash-integrity/#integration-tests","title":"Integration Tests","text":"<pre><code>[Test]\npublic async Task Should_Replay_From_Valid_Snapshot_When_Data_Intact()\n{\n    // Create snapshot with valid hash\n    var state = new UserAggregate(\"user-1\", \"test@example.com\", \"Test User\", UserStatus.Active, 5);\n    var snapshot = await CreateValidSnapshotAsync(\"user-1\", state);\n\n    // Replay should use snapshot\n    var replayedState = await streamManager.ReplayEventsAsync&lt;UserAggregate&gt;(\"user-1\");\n\n    Assert.That(replayedState.Version, Is.EqualTo(5)); // Used snapshot, not full replay\n}\n\n[Test] \npublic async Task Should_Skip_Corrupted_Snapshot_And_Replay_From_Beginning()\n{\n    // Create corrupted snapshot\n    await CreateCorruptedSnapshotAsync(\"user-1\");\n\n    // Should detect corruption and replay from beginning\n    var replayedState = await streamManager.ReplayEventsAsync&lt;UserAggregate&gt;(\"user-1\");\n\n    // Verify full replay occurred (check logs or metrics)\n    Assert.That(GetReplaySource(\"user-1\"), Is.EqualTo(ReplaySource.FullReplay));\n}\n</code></pre>"},{"location":"guide/hash-integrity/#best-practices","title":"Best Practices","text":""},{"location":"guide/hash-integrity/#handler-stability","title":"Handler Stability","text":"<p>Write stable handlers to minimize unnecessary replays:</p> <pre><code>// \u2705 Good: Stable, focused handler\npublic static UserAggregate Handle(UserAggregate? state, UserCreated @event)\n    =&gt; new UserAggregate(@event.UserId, @event.Name, @event.Email, (state?.Version ?? 0) + 1);\n\n// \u274c Avoid: Handler with changing implementation details\npublic static UserAggregate Handle(UserAggregate? state, UserCreated @event)\n{\n    // Avoid complex logic that might change\n    var validationResult = ComplexValidation(@event); // This might change\n    var processedName = ApplyBusinessRules(@event.Name); // This might change\n\n    return new UserAggregate(@event.UserId, processedName, @event.Email, (state?.Version ?? 0) + 1);\n}\n</code></pre>"},{"location":"guide/hash-integrity/#separation-of-concerns","title":"Separation of Concerns","text":"<p>Keep event handlers pure and move complex logic elsewhere:</p> <pre><code>// \u2705 Good: Pure handler with preprocessed data\npublic record UserCreated(string UserId, string Name, string Email, bool IsValidated);\n\npublic static UserAggregate Handle(UserAggregate? state, UserCreated @event)\n    =&gt; new UserAggregate(@event.UserId, @event.Name, @event.Email, (state?.Version ?? 0) + 1);\n\n// Complex validation happens before event creation\npublic async Task&lt;UserCreated&gt; CreateValidatedUserEvent(string name, string email)\n{\n    var isValid = await _validationService.ValidateAsync(name, email);\n    return new UserCreated(Guid.NewGuid().ToString(), name, email, isValid);\n}\n</code></pre>"},{"location":"guide/hash-integrity/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Event Replay strategies</li> <li>Understand Storage Providers and their integrity features</li> <li>Explore Performance optimization techniques</li> <li>See Migration Strategies for handling schema changes</li> </ul>"},{"location":"guide/snapshots/","title":"Snapshots","text":"<p>Snapshots in StreamDingo provide performance optimization by caching aggregate state at specific points, reducing the need to replay all events from the beginning.</p>"},{"location":"guide/snapshots/#what-are-snapshots","title":"What are Snapshots?","text":"<p>Snapshots are serialized representations of aggregate state at a particular point in time, along with integrity verification hashes.</p> <pre><code>public record SnapshotMetadata(\n    string StreamId,\n    long EventVersion,\n    DateTime CreatedAt,\n    string AggregateHash,\n    string SnapshotHash\n);\n\npublic record Snapshot&lt;TAggregate&gt;(\n    TAggregate State,\n    SnapshotMetadata Metadata\n);\n</code></pre>"},{"location":"guide/snapshots/#snapshot-creation","title":"Snapshot Creation","text":""},{"location":"guide/snapshots/#automatic-snapshots","title":"Automatic Snapshots","text":"<p>Configure automatic snapshot creation:</p> <pre><code>services.Configure&lt;SnapshotOptions&gt;(options =&gt;\n{\n    options.SnapshotEveryNEvents = 100;    // Create snapshot every 100 events\n    options.MaxSnapshotsPerStream = 10;    // Keep last 10 snapshots\n    options.EnableAutomaticSnapshots = true;\n});\n</code></pre>"},{"location":"guide/snapshots/#manual-snapshots","title":"Manual Snapshots","text":"<p>Create snapshots manually at strategic points:</p> <pre><code>var currentState = await streamManager.ReplayEventsAsync&lt;UserAggregate&gt;(userId);\nawait snapshotStore.SaveSnapshotAsync(userId, currentState);\n</code></pre>"},{"location":"guide/snapshots/#hash-based-integrity","title":"Hash-Based Integrity","text":""},{"location":"guide/snapshots/#snapshot-hashing","title":"Snapshot Hashing","text":"<p>Each snapshot includes multiple hashes for integrity verification:</p> <pre><code>graph TB\n    A[Aggregate State] --&gt; B[Serialize]\n    B --&gt; C[Hash Snapshot Data]\n    D[Event Handler Code] --&gt; E[Hash Handler Code] \n    C --&gt; F[Store Snapshot]\n    E --&gt; F\n    F --&gt; G[Snapshot with Hashes]</code></pre>"},{"location":"guide/snapshots/#verification-process","title":"Verification Process","text":"<p>When loading snapshots, hashes are verified:</p> <pre><code>public async Task&lt;Snapshot&lt;TAggregate&gt;?&gt; LoadVerifiedSnapshotAsync&lt;TAggregate&gt;(string streamId)\n{\n    var snapshot = await snapshotStore.GetSnapshotAsync&lt;TAggregate&gt;(streamId);\n    if (snapshot == null) return null;\n\n    // Verify snapshot data integrity\n    var currentSnapshotHash = hashProvider.HashObject(snapshot.State);\n    if (currentSnapshotHash != snapshot.Metadata.SnapshotHash)\n    {\n        logger.LogWarning(\"Snapshot data corruption detected for {StreamId}\", streamId);\n        return null; // Force full replay\n    }\n\n    // Verify handler code hasn't changed\n    var currentHandlerHash = hashProvider.HashEventHandlers&lt;TAggregate&gt;();\n    if (currentHandlerHash != snapshot.Metadata.AggregateHash)\n    {\n        logger.LogInformation(\"Event handler code changed for {StreamId}, replay required\", streamId);\n        return null; // Force replay due to handler changes\n    }\n\n    return snapshot;\n}\n</code></pre>"},{"location":"guide/snapshots/#snapshot-strategies","title":"Snapshot Strategies","text":""},{"location":"guide/snapshots/#frequency-based","title":"Frequency-Based","text":"<p>Create snapshots based on event count:</p> <pre><code>public class FrequencySnapshotStrategy : ISnapshotStrategy\n{\n    private readonly int _eventFrequency;\n\n    public FrequencySnapshotStrategy(int eventFrequency = 100)\n    {\n        _eventFrequency = eventFrequency;\n    }\n\n    public bool ShouldCreateSnapshot(long currentVersion, DateTime lastSnapshotTime)\n    {\n        return currentVersion % _eventFrequency == 0;\n    }\n}\n</code></pre>"},{"location":"guide/snapshots/#time-based","title":"Time-Based","text":"<p>Create snapshots based on time intervals:</p> <pre><code>public class TimeBasedSnapshotStrategy : ISnapshotStrategy\n{\n    private readonly TimeSpan _interval;\n\n    public TimeBasedSnapshotStrategy(TimeSpan interval)\n    {\n        _interval = interval;\n    }\n\n    public bool ShouldCreateSnapshot(long currentVersion, DateTime lastSnapshotTime)\n    {\n        return DateTime.UtcNow - lastSnapshotTime &gt; _interval;\n    }\n}\n</code></pre>"},{"location":"guide/snapshots/#hybrid-strategy","title":"Hybrid Strategy","text":"<p>Combine multiple strategies:</p> <pre><code>public class HybridSnapshotStrategy : ISnapshotStrategy\n{\n    public bool ShouldCreateSnapshot(long currentVersion, DateTime lastSnapshotTime)\n    {\n        // Create snapshot if either condition is met\n        return currentVersion % 100 == 0 || // Every 100 events\n               DateTime.UtcNow - lastSnapshotTime &gt; TimeSpan.FromHours(1); // Every hour\n    }\n}\n</code></pre>"},{"location":"guide/snapshots/#snapshot-storage","title":"Snapshot Storage","text":""},{"location":"guide/snapshots/#in-memory-storage","title":"In-Memory Storage","text":"<p>For development and testing:</p> <pre><code>public class InMemorySnapshotStore : ISnapshotStore\n{\n    private readonly ConcurrentDictionary&lt;string, object&gt; _snapshots = new();\n\n    public Task SaveSnapshotAsync&lt;TAggregate&gt;(string streamId, Snapshot&lt;TAggregate&gt; snapshot)\n    {\n        _snapshots[streamId] = snapshot;\n        return Task.CompletedTask;\n    }\n\n    public Task&lt;Snapshot&lt;TAggregate&gt;?&gt; GetSnapshotAsync&lt;TAggregate&gt;(string streamId)\n    {\n        return Task.FromResult(_snapshots.TryGetValue(streamId, out var snapshot) \n            ? (Snapshot&lt;TAggregate&gt;?)snapshot \n            : null);\n    }\n}\n</code></pre>"},{"location":"guide/snapshots/#database-storage","title":"Database Storage","text":"<p>For production scenarios:</p> <pre><code>public class SqlSnapshotStore : ISnapshotStore\n{\n    public async Task SaveSnapshotAsync&lt;TAggregate&gt;(string streamId, Snapshot&lt;TAggregate&gt; snapshot)\n    {\n        var json = JsonSerializer.Serialize(snapshot.State);\n\n        await connection.ExecuteAsync(@\"\n            INSERT INTO Snapshots (StreamId, AggregateType, Version, Data, CreatedAt, SnapshotHash, AggregateHash)\n            VALUES (@StreamId, @AggregateType, @Version, @Data, @CreatedAt, @SnapshotHash, @AggregateHash)\",\n            new\n            {\n                StreamId = streamId,\n                AggregateType = typeof(TAggregate).FullName,\n                Version = snapshot.Metadata.EventVersion,\n                Data = json,\n                CreatedAt = snapshot.Metadata.CreatedAt,\n                SnapshotHash = snapshot.Metadata.SnapshotHash,\n                AggregateHash = snapshot.Metadata.AggregateHash\n            });\n    }\n}\n</code></pre>"},{"location":"guide/snapshots/#replay-from-snapshots","title":"Replay from Snapshots","text":""},{"location":"guide/snapshots/#optimal-replay-strategy","title":"Optimal Replay Strategy","text":"<p>StreamDingo automatically chooses the best replay strategy:</p> <pre><code>flowchart TD\n    A[Request Aggregate] --&gt; B{Valid Snapshot Available?}\n    B --&gt;|Yes| C[Load from Snapshot]\n    B --&gt;|No| D[Full Replay from Beginning]\n    C --&gt; E[Replay Events Since Snapshot]\n    E --&gt; F[Current State]\n    D --&gt; F</code></pre>"},{"location":"guide/snapshots/#implementation","title":"Implementation","text":"<pre><code>public async Task&lt;TAggregate?&gt; ReplayEventsAsync&lt;TAggregate&gt;(string streamId)\n{\n    // Try to load verified snapshot\n    var snapshot = await LoadVerifiedSnapshotAsync&lt;TAggregate&gt;(streamId);\n\n    TAggregate? currentState;\n    long fromVersion;\n\n    if (snapshot != null)\n    {\n        currentState = snapshot.State;\n        fromVersion = snapshot.Metadata.EventVersion + 1;\n        logger.LogDebug(\"Loaded snapshot for {StreamId} at version {Version}\", \n            streamId, snapshot.Metadata.EventVersion);\n    }\n    else\n    {\n        currentState = default;\n        fromVersion = 0;\n        logger.LogDebug(\"No valid snapshot found for {StreamId}, replaying from beginning\", streamId);\n    }\n\n    // Replay events from snapshot point or beginning\n    var events = await eventStore.GetEventsAsync(streamId, fromVersion);\n    return await ApplyEventsAsync(currentState, events);\n}\n</code></pre>"},{"location":"guide/snapshots/#snapshot-cleanup","title":"Snapshot Cleanup","text":""},{"location":"guide/snapshots/#automatic-cleanup","title":"Automatic Cleanup","text":"<p>Remove old snapshots to save storage:</p> <pre><code>public class SnapshotCleanupService : IHostedService\n{\n    private readonly Timer _timer;\n    private readonly ISnapshotStore _snapshotStore;\n\n    public async Task ExecuteAsync()\n    {\n        var cutoffDate = DateTime.UtcNow.AddDays(-30); // Keep 30 days\n        await _snapshotStore.DeleteSnapshotsOlderThanAsync(cutoffDate);\n    }\n}\n</code></pre>"},{"location":"guide/snapshots/#retention-policies","title":"Retention Policies","text":"<p>Configure different retention policies:</p> <pre><code>services.Configure&lt;SnapshotRetentionOptions&gt;(options =&gt;\n{\n    options.RetentionPolicies.Add(new SnapshotRetentionPolicy\n    {\n        AggregateType = typeof(UserAggregate),\n        MaxSnapshots = 5,\n        MaxAge = TimeSpan.FromDays(90)\n    });\n\n    options.RetentionPolicies.Add(new SnapshotRetentionPolicy\n    {\n        AggregateType = typeof(OrderAggregate),\n        MaxSnapshots = 10,\n        MaxAge = TimeSpan.FromDays(365) // Orders kept longer\n    });\n});\n</code></pre>"},{"location":"guide/snapshots/#performance-optimization","title":"Performance Optimization","text":""},{"location":"guide/snapshots/#snapshot-size-optimization","title":"Snapshot Size Optimization","text":"<p>Keep snapshots small for better performance:</p> <pre><code>// \u2705 Good: Minimal snapshot\npublic record UserAggregateSnapshot(\n    string Id,\n    string Email,\n    UserStatus Status,\n    int Version\n);\n\n// \u274c Avoid: Including derived/computable data\npublic record UserAggregateSnapshotBad(\n    string Id,\n    string Email,\n    UserStatus Status,\n    int Version,\n    string DisplayName,        // Can be computed\n    List&lt;string&gt; EventHistory, // Stored separately\n    Dictionary&lt;string, object&gt; Cache // Runtime data\n);\n</code></pre>"},{"location":"guide/snapshots/#compression","title":"Compression","text":"<p>Compress large snapshots:</p> <pre><code>public async Task SaveSnapshotAsync&lt;TAggregate&gt;(string streamId, Snapshot&lt;TAggregate&gt; snapshot)\n{\n    var json = JsonSerializer.Serialize(snapshot.State);\n    var compressed = await CompressionHelper.CompressAsync(json);\n\n    // Store compressed data\n    await StoreCompressedSnapshotAsync(streamId, compressed, snapshot.Metadata);\n}\n</code></pre>"},{"location":"guide/snapshots/#testing-snapshots","title":"Testing Snapshots","text":""},{"location":"guide/snapshots/#snapshot-creation-tests","title":"Snapshot Creation Tests","text":"<pre><code>[Test]\npublic async Task Should_Create_Snapshot_After_Threshold()\n{\n    // Arrange\n    var options = Options.Create(new SnapshotOptions { SnapshotEveryNEvents = 5 });\n    var streamManager = new EventStreamManager(eventStore, snapshotStore, options);\n\n    // Act: Add events up to threshold\n    var events = Enumerable.Range(1, 5)\n        .Select(i =&gt; new UserEmailChanged($\"user-1\", $\"email{i}@example.com\"))\n        .Cast&lt;object&gt;();\n\n    await streamManager.AppendEventsAsync(\"user-1\", events);\n\n    // Assert\n    var snapshot = await snapshotStore.GetSnapshotAsync&lt;UserAggregate&gt;(\"user-1\");\n    Assert.That(snapshot, Is.Not.Null);\n    Assert.That(snapshot.Metadata.EventVersion, Is.EqualTo(5));\n}\n</code></pre>"},{"location":"guide/snapshots/#hash-verification-tests","title":"Hash Verification Tests","text":"<pre><code>[Test]\npublic async Task Should_Reject_Corrupted_Snapshot()\n{\n    // Arrange\n    var validSnapshot = new Snapshot&lt;UserAggregate&gt;(\n        new UserAggregate(\"user-1\", \"test@example.com\", \"Test User\", UserStatus.Active, 5),\n        new SnapshotMetadata(\"user-1\", 5, DateTime.UtcNow, \"valid-hash\", \"valid-snapshot-hash\")\n    );\n\n    await snapshotStore.SaveSnapshotAsync(\"user-1\", validSnapshot);\n\n    // Act: Corrupt the snapshot hash\n    await CorruptSnapshotHashAsync(\"user-1\");\n\n    // Assert\n    var loadedSnapshot = await LoadVerifiedSnapshotAsync&lt;UserAggregate&gt;(\"user-1\");\n    Assert.That(loadedSnapshot, Is.Null); // Should be rejected\n}\n</code></pre>"},{"location":"guide/snapshots/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"guide/snapshots/#snapshot-version-mismatch","title":"Snapshot Version Mismatch","text":"<pre><code>// Problem: Aggregate schema changed but snapshot is old version\npublic record UserAggregateV1(string Id, string Email);\npublic record UserAggregateV2(string Id, string Email, string PhoneNumber);\n\n// Solution: Version-aware snapshot loading\npublic async Task&lt;Snapshot&lt;TAggregate&gt;?&gt; GetSnapshotAsync&lt;TAggregate&gt;(string streamId)\n{\n    var snapshotData = await LoadSnapshotDataAsync(streamId);\n    if (snapshotData == null) return null;\n\n    return snapshotData.AggregateVersion switch\n    {\n        1 =&gt; MigrateFromV1&lt;TAggregate&gt;(snapshotData),\n        2 =&gt; DeserializeV2&lt;TAggregate&gt;(snapshotData),\n        _ =&gt; throw new NotSupportedException($\"Unsupported snapshot version: {snapshotData.AggregateVersion}\")\n    };\n}\n</code></pre>"},{"location":"guide/snapshots/#performance-issues","title":"Performance Issues","text":"<p>Monitor snapshot performance:</p> <pre><code>public async Task&lt;TAggregate?&gt; ReplayEventsAsync&lt;TAggregate&gt;(string streamId)\n{\n    using var activity = _activitySource.StartActivity(\"ReplayEvents\");\n    activity?.SetTag(\"StreamId\", streamId);\n    activity?.SetTag(\"AggregateType\", typeof(TAggregate).Name);\n\n    var stopwatch = Stopwatch.StartNew();\n    var snapshot = await LoadVerifiedSnapshotAsync&lt;TAggregate&gt;(streamId);\n\n    if (snapshot != null)\n    {\n        activity?.SetTag(\"SnapshotUsed\", true);\n        activity?.SetTag(\"SnapshotVersion\", snapshot.Metadata.EventVersion);\n    }\n\n    var result = await ReplayFromSnapshot(snapshot, streamId);\n\n    activity?.SetTag(\"ReplayDurationMs\", stopwatch.ElapsedMilliseconds);\n    return result;\n}\n</code></pre>"},{"location":"guide/snapshots/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Hash Integrity verification in detail</li> <li>Understand Event Replay strategies  </li> <li>Explore Storage Providers for different backends</li> <li>See Performance optimization techniques</li> </ul>"},{"location":"guide/storage-providers/","title":"Storage Providers","text":"<p>StreamDingo supports multiple storage providers for events and snapshots, allowing you to choose the best backend for your needs.</p>"},{"location":"guide/storage-providers/#available-providers","title":"Available Providers","text":""},{"location":"guide/storage-providers/#in-memory-storage","title":"In-Memory Storage","text":"<p>Perfect for development, testing, and prototyping:</p> <pre><code>services.AddSingleton&lt;IEventStore, InMemoryEventStore&gt;();\nservices.AddSingleton&lt;ISnapshotStore, InMemorySnapshotStore&gt;();\n</code></pre>"},{"location":"guide/storage-providers/#sql-server-provider","title":"SQL Server Provider","text":"<p>Production-ready relational storage:</p> <pre><code>services.AddSqlServerEventStore(connectionString);\nservices.AddSqlServerSnapshotStore(connectionString);\n</code></pre>"},{"location":"guide/storage-providers/#postgresql-provider","title":"PostgreSQL Provider","text":"<p>Open-source relational storage with JSONB support:</p> <pre><code>services.AddPostgreSqlEventStore(connectionString);\nservices.AddPostgreSqlSnapshotStore(connectionString);\n</code></pre>"},{"location":"guide/storage-providers/#configuration","title":"Configuration","text":""},{"location":"guide/storage-providers/#connection-strings","title":"Connection Strings","text":"<pre><code>services.Configure&lt;StorageOptions&gt;(options =&gt;\n{\n    options.EventStoreConnectionString = \"Server=...;Database=Events;\";\n    options.SnapshotStoreConnectionString = \"Server=...;Database=Snapshots;\";\n    options.EnableConnectionPooling = true;\n    options.CommandTimeout = TimeSpan.FromSeconds(30);\n});\n</code></pre>"},{"location":"guide/storage-providers/#performance-tuning","title":"Performance Tuning","text":"<pre><code>services.Configure&lt;EventStoreOptions&gt;(options =&gt;\n{\n    options.BatchSize = 1000;\n    options.EnableBulkInsert = true;\n    options.UseCompression = true;\n});\n</code></pre>"},{"location":"guide/storage-providers/#custom-providers","title":"Custom Providers","text":"<p>Implement <code>IEventStore</code> and <code>ISnapshotStore</code> for custom storage:</p> <pre><code>public class CustomEventStore : IEventStore\n{\n    public async Task AppendEventsAsync(string streamId, IEnumerable&lt;object&gt; events)\n    {\n        // Custom implementation\n    }\n\n    public async Task&lt;IEnumerable&lt;object&gt;&gt; GetEventsAsync(string streamId, long fromVersion = 0)\n    {\n        // Custom implementation\n    }\n}\n</code></pre>"},{"location":"guide/storage-providers/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Custom Providers</li> <li>Explore Performance optimization</li> </ul>"}]}