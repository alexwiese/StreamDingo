<h1 id="streamdingo-technical-specification">StreamDingo - Technical Specification</h1>
<blockquote>
<p><strong>Event Sourcing .NET Library with Hash-Based Integrity Verification</strong></p>
</blockquote>
<h2 id="overview">ğŸ¯ Overview</h2>
<p>StreamDingo is a high-performance .NET library for event sourcing that provides:</p>
<ul>
<li><strong>Hash-based integrity verification</strong> using alexwiese/hashstamp</li>
<li><strong>Snapshot-based event replay</strong> for efficient state reconstruction</li>
<li><strong>Intelligent replay optimization</strong> when event handlers change</li>
<li><strong>Production-ready performance</strong> with minimal allocations</li>
</ul>
<h2 id="architecture">ğŸ—ï¸ Architecture</h2>
<h3 id="core-components">Core Components</h3>
<h4 id="event-handler-system">1. Event Handler System</h4>
<pre><code class="language-csharp">public interface IEventHandler&lt;TState, TEvent&gt;
    where TState : class
    where TEvent : IEvent
{
    TState Handle(TState? previousSnapshot, TEvent &#64;event);
}
</code></pre>
<p><strong>Key Features:</strong></p>
<ul>
<li>Pure functions: <code>(previousSnapshot, event) â†’ newSnapshot</code></li>
<li>Stateless and deterministic</li>
<li>Hash-verified using hashstamp source generator</li>
<li>Support for both mutable and immutable state objects</li>
</ul>
<h4 id="event-store-abstraction">2. Event Store Abstraction</h4>
<pre><code class="language-csharp">public interface IEventStore
{
    ValueTask AppendEventAsync&lt;T&gt;(string streamId, T &#64;event, CancellationToken cancellationToken = default)
        where T : IEvent;
    
    IAsyncEnumerable&lt;IEvent&gt; ReadEventsAsync(string streamId, long fromVersion = 0, 
        CancellationToken cancellationToken = default);
    
    ValueTask&lt;Snapshot&lt;T&gt;?&gt; GetLatestSnapshotAsync&lt;T&gt;(string streamId, 
        CancellationToken cancellationToken = default) where T : class;
    
    ValueTask SaveSnapshotAsync&lt;T&gt;(string streamId, Snapshot&lt;T&gt; snapshot, 
        CancellationToken cancellationToken = default) where T : class;
}
</code></pre>
<h4 id="snapshot-management">3. Snapshot Management</h4>
<pre><code class="language-csharp">public class Snapshot&lt;T&gt; where T : class
{
    public string StreamId { get; init; }
    public long Version { get; init; }
    public T State { get; init; }
    public string Hash { get; init; }
    public DateTime CreatedAt { get; init; }
    public Dictionary&lt;string, string&gt; HandlerHashes { get; init; }
}
</code></pre>
<p><strong>Hash Integrity Features:</strong></p>
<ul>
<li><strong>State Hash</strong>: SHA-256 of serialized state data</li>
<li><strong>Handler Hashes</strong>: Hash of each event handler's source code</li>
<li><strong>Snapshot Verification</strong>: Detect tampering or corruption</li>
<li><strong>Handler Change Detection</strong>: Trigger replay when code changes</li>
</ul>
<h4 id="event-replay-engine">4. Event Replay Engine</h4>
<pre><code class="language-csharp">public interface IEventReplayEngine
{
    ValueTask&lt;T&gt; ReplayEventsAsync&lt;T&gt;(string streamId, 
        CancellationToken cancellationToken = default) where T : class;
    
    ValueTask&lt;T&gt; ReplayFromSnapshotAsync&lt;T&gt;(string streamId, Snapshot&lt;T&gt; snapshot,
        CancellationToken cancellationToken = default) where T : class;
}
</code></pre>
<p><strong>Intelligent Replay Logic:</strong></p>
<ol>
<li>Load latest snapshot</li>
<li>Compare handler hashes with current code</li>
<li>If hashes match: replay from latest snapshot</li>
<li>If hashes differ: find last compatible snapshot or replay from beginning</li>
<li>Apply events sequentially using current handlers</li>
<li>Create new snapshot when complete</li>
</ol>
<h3 id="event-sourcing-flow">Event Sourcing Flow</h3>
<div class="mermaid">graph TD
    A[Append Event] --> B[Load Latest Snapshot]
    B --> C{Handler Hashes Match?}
    C -->|Yes| D[Apply Event to Snapshot]
    C -->|No| E[Find Compatible Snapshot]
    E --> F{Compatible Found?}
    F -->|Yes| G[Replay from Compatible Snapshot]
    F -->|No| H[Replay from Beginning]
    G --> D
    H --> D
    D --> I[Save New Snapshot]
    I --> J[Update State Hash]
    J --> K[Store Handler Hashes]
</div>
<h2 id="performance-targets">ğŸš€ Performance Targets</h2>
<h3 id="throughput-targets">Throughput Targets</h3>
<ul>
<li><strong>Event Append</strong>: &gt;100,000 events/second</li>
<li><strong>Event Replay</strong>: &gt;500,000 events/second</li>
<li><strong>Snapshot Creation</strong>: &gt;10,000 snapshots/second</li>
<li><strong>Hash Verification</strong>: &gt;1,000,000 hashes/second</li>
</ul>
<h3 id="memory-targets">Memory Targets</h3>
<ul>
<li><strong>1M Events + Snapshots</strong>: &lt;1GB memory usage</li>
<li><strong>Event Processing</strong>: &lt;1KB allocations per event</li>
<li><strong>Snapshot Storage</strong>: &lt;500MB for 10,000 snapshots</li>
<li><strong>Hash Cache</strong>: &lt;50MB for 100,000 handler hashes</li>
</ul>
<h3 id="latency-targets">Latency Targets</h3>
<ul>
<li><strong>Single Event Append</strong>: &lt;1ms P99</li>
<li><strong>Snapshot Lookup</strong>: &lt;0.5ms P99</li>
<li><strong>Hash Verification</strong>: &lt;0.1ms P99</li>
<li><strong>Event Replay</strong>: &lt;10ms P99 for 1,000 events</li>
</ul>
<h2 id="api-design-principles">ğŸ”§ API Design Principles</h2>
<h3 id="simplicity-first">1. Simplicity First</h3>
<ul>
<li>Minimal configuration required</li>
<li>Fluent builder patterns for setup</li>
<li>Convention over configuration</li>
<li>Clear error messages and exceptions</li>
</ul>
<h3 id="performance-optimized">2. Performance Optimized</h3>
<ul>
<li><code>ValueTask&lt;T&gt;</code> for potentially synchronous operations</li>
<li>Object pooling for frequent allocations</li>
<li>Span<T> and Memory<T> for buffer management</li>
<li>Zero-allocation paths where possible</li>
</ul>
<h3 id="extensibility">3. Extensibility</h3>
<ul>
<li>Pluggable event store implementations</li>
<li>Custom serialization support</li>
<li>Configurable snapshot policies</li>
<li>Event transformation and middleware</li>
</ul>
<h3 id="production-ready">4. Production Ready</h3>
<ul>
<li>Comprehensive logging and telemetry</li>
<li>Circuit breaker patterns for reliability</li>
<li>Retry policies with exponential backoff</li>
<li>Health checks and monitoring integration</li>
</ul>
<h2 id="package-structure">ğŸ“¦ Package Structure</h2>
<h3 id="core-package-streamdingo">Core Package: StreamDingo</h3>
<pre><code>StreamDingo/
â”œâ”€â”€ EventSourcing/
â”‚   â”œâ”€â”€ IEvent.cs
â”‚   â”œâ”€â”€ IEventHandler.cs
â”‚   â”œâ”€â”€ IEventStore.cs
â”‚   â””â”€â”€ EventReplayEngine.cs
â”œâ”€â”€ Snapshots/
â”‚   â”œâ”€â”€ Snapshot.cs
â”‚   â”œâ”€â”€ ISnapshotStore.cs
â”‚   â””â”€â”€ SnapshotManager.cs
â”œâ”€â”€ Integrity/
â”‚   â”œâ”€â”€ IHashProvider.cs
â”‚   â”œâ”€â”€ HashStampIntegration.cs
â”‚   â””â”€â”€ IntegrityVerifier.cs
â””â”€â”€ Configuration/
    â”œâ”€â”€ StreamDingoOptions.cs
    â””â”€â”€ EventSourcingBuilder.cs
</code></pre>
<h3 id="storage-providers-separate-packages">Storage Providers (Separate Packages)</h3>
<ul>
<li><strong>StreamDingo.SqlServer</strong>: SQL Server provider</li>
<li><strong>StreamDingo.PostgreSQL</strong>: PostgreSQL provider</li>
<li><strong>StreamDingo.InMemory</strong>: In-memory provider for testing</li>
<li><strong>StreamDingo.FileSystem</strong>: File-based provider for simple scenarios</li>
</ul>
<h2 id="integration-with-hashstamp">ğŸ”„ Integration with HashStamp</h2>
<h3 id="setup-integration">Setup Integration</h3>
<pre><code class="language-csharp">// In StreamDingo.csproj
&lt;PackageReference Include=&quot;HashStamp&quot; Version=&quot;1.0.0&quot; PrivateAssets=&quot;analyzers&quot; /&gt;
</code></pre>
<h3 id="usage-pattern">Usage Pattern</h3>
<pre><code class="language-csharp">// Event handlers automatically get hashes generated
public class OrderEventHandler : IEventHandler&lt;OrderState, OrderCreated&gt;
{
    public OrderState Handle(OrderState? previous, OrderCreated &#64;event)
    {
        // Method body hash: HashStamps.OrderEventHandler.Handle
        return new OrderState 
        { 
            Id = &#64;event.OrderId, 
            Status = &quot;Created&quot; 
        };
    }
}

// Integrity verification
var currentHash = HashStamps.OrderEventHandler.Handle;
var snapshotHash = snapshot.HandlerHashes[&quot;OrderEventHandler.Handle&quot;];
var needsReplay = currentHash != snapshotHash;
</code></pre>
<h2 id="use-cases-and-user-personas">ğŸ“Š Use Cases and User Personas</h2>
<h3 id="primary-use-cases">Primary Use Cases</h3>
<ol>
<li><p><strong>Financial Transaction Systems</strong></p>
<ul>
<li>Audit trails for regulatory compliance</li>
<li>Event replay for transaction verification</li>
<li>State reconstruction for balance calculations</li>
</ul>
</li>
<li><p><strong>E-commerce Order Management</strong></p>
<ul>
<li>Order lifecycle tracking</li>
<li>Inventory state management</li>
<li>Customer interaction history</li>
</ul>
</li>
<li><p><strong>IoT Data Processing</strong></p>
<ul>
<li>Sensor data aggregation</li>
<li>Device state tracking</li>
<li>Historical data analysis</li>
</ul>
</li>
<li><p><strong>Domain Event Systems</strong></p>
<ul>
<li>Microservice communication</li>
<li>CQRS implementation</li>
<li>Distributed system coordination</li>
</ul>
</li>
</ol>
<h3 id="user-personas">User Personas</h3>
<h4 id="enterprise-developer">1. Enterprise Developer</h4>
<ul>
<li><strong>Needs</strong>: Reliable, well-documented, production-ready</li>
<li><strong>Priorities</strong>: Performance, security, compliance</li>
<li><strong>Pain Points</strong>: Complex setup, poor documentation</li>
</ul>
<h4 id="startup-developer">2. Startup Developer</h4>
<ul>
<li><strong>Needs</strong>: Quick setup, flexible, cost-effective</li>
<li><strong>Priorities</strong>: Rapid development, scalability</li>
<li><strong>Pain Points</strong>: Over-engineering, expensive licenses</li>
</ul>
<h4 id="open-source-contributor">3. Open Source Contributor</h4>
<ul>
<li><strong>Needs</strong>: Clean code, good test coverage, clear contribution guidelines</li>
<li><strong>Priorities</strong>: Code quality, learning opportunities</li>
<li><strong>Pain Points</strong>: Poor project structure, lack of tests</li>
</ul>
<h2 id="success-metrics">ğŸ¯ Success Metrics</h2>
<h3 id="technical-metrics">Technical Metrics</h3>
<ul>
<li><strong>Test Coverage</strong>: &gt;90% line coverage</li>
<li><strong>Performance</strong>: Meet all latency and throughput targets</li>
<li><strong>Memory</strong>: Zero detectable memory leaks</li>
<li><strong>Security</strong>: Zero high-severity vulnerabilities</li>
</ul>
<h3 id="community-metrics">Community Metrics</h3>
<ul>
<li><strong>GitHub Stars</strong>: &gt;100 within 3 months</li>
<li><strong>NuGet Downloads</strong>: &gt;1,000 within 6 months</li>
<li><strong>Community PRs</strong>: &gt;5 external contributions</li>
<li><strong>Issue Response</strong>: &lt;48 hours average response time</li>
</ul>
<h3 id="quality-metrics">Quality Metrics</h3>
<ul>
<li><strong>Documentation</strong>: 100% public API documented</li>
<li><strong>Examples</strong>: &gt;5 comprehensive usage examples</li>
<li><strong>Breaking Changes</strong>: &lt;1 per major version</li>
<li><strong>Bug Reports</strong>: &lt;10 open bugs at any time</li>
</ul>
<h2 id="security-considerations">ğŸ”’ Security Considerations</h2>
<h3 id="hash-integrity">Hash Integrity</h3>
<ul>
<li>SHA-256 for all hash calculations</li>
<li>Collision detection and handling</li>
<li>Secure hash storage and transmission</li>
<li>Protection against hash manipulation</li>
</ul>
<h3 id="data-protection">Data Protection</h3>
<ul>
<li>Optional encryption for sensitive events</li>
<li>Secure snapshot storage</li>
<li>Audit trail protection</li>
<li>GDPR compliance considerations</li>
</ul>
<h3 id="access-control">Access Control</h3>
<ul>
<li>Event store access controls</li>
<li>Snapshot access permissions</li>
<li>Administrative operation restrictions</li>
<li>API rate limiting capabilities</li>
</ul>
<h2 id="testing-strategy">ğŸ§ª Testing Strategy</h2>
<h3 id="unit-testing-90-coverage">Unit Testing (&gt;90% Coverage)</h3>
<ul>
<li>Event handler registration and execution</li>
<li>Snapshot creation and validation</li>
<li>Hash calculation and verification</li>
<li>Error handling and edge cases</li>
<li>Serialization and deserialization</li>
</ul>
<h3 id="integration-testing">Integration Testing</h3>
<ul>
<li>End-to-end event sourcing scenarios</li>
<li>Storage provider integration</li>
<li>Concurrency and thread safety</li>
<li>Performance under load</li>
<li>Data corruption recovery</li>
</ul>
<h3 id="performance-testing">Performance Testing</h3>
<ul>
<li>Throughput benchmarks</li>
<li>Memory allocation profiling</li>
<li>Latency measurements</li>
<li>Stress testing scenarios</li>
<li>Scalability validation</li>
</ul>
<h2 id="monitoring-and-observability">ğŸ“ˆ Monitoring and Observability</h2>
<h3 id="metrics">Metrics</h3>
<ul>
<li>Event processing rates</li>
<li>Snapshot creation frequency</li>
<li>Hash verification timing</li>
<li>Memory usage patterns</li>
<li>Error rates and types</li>
</ul>
<h3 id="logging">Logging</h3>
<ul>
<li>Structured logging with Serilog</li>
<li>Correlation IDs for request tracking</li>
<li>Performance counters</li>
<li>Error details and stack traces</li>
<li>Debug information for development</li>
</ul>
<h3 id="health-checks">Health Checks</h3>
<ul>
<li>Event store connectivity</li>
<li>Snapshot store accessibility</li>
<li>Hash verification integrity</li>
<li>Memory usage thresholds</li>
<li>Performance degradation detection</li>
</ul>
<hr />
<p><strong>Last Updated</strong>: $(date)<br />
<strong>Version</strong>: 1.0<br />
<strong>Status</strong>: Draft</p>
